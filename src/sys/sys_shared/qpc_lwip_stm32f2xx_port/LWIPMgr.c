/*****************************************************************************
* Model: LWIPMgr.qm
* File:  ./LWIPMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::LWIPMgr_gen.c} ......................................................*/
/**
 * @file     LWIPMgr.c
 * @brief This file contains the definitions of the LWIPMgr Active Object and
 * its state machines.
 *
 * LWIPMgr is responsible for handling all communications with the ethernet
 * driver.  It is the only state machine that has exclusive access to the
 * ethernet hardware and facilitates sharing by allowing other state machines
 * to publish events to the QPC RTOS.  QPC queues the events to be handled by
 * the LWIPMgr state machine in the FIFO order.
 *
 * Note: If editing this file, please make sure to update the LWIPMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date       06/09/2014
 * @author     Harry Rostovtsev
 * @email      harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 */

#define LWIP_ALLOWED     /* This must be set before the include to allow LWIP */

/* Includes ------------------------------------------------------------------*/
#include "LWIPMgr.h"
#include "lwip.h"                                             /* lwIP stack */

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */
Q_ASSERT_COMPILE(MAX_SHARED_SIG < DEV_DRIVER_SIG);/* app signal overlap check */

/* Private typedefs ----------------------------------------------------------*/
/**
 * \enum TCP socket states.
 */
enum echo_states {
    ES_NONE = 0,                                        /**< Default no state */
    ES_ACCEPTED,                                     /**< Connection accepted */
    ES_RECEIVED,                             /**< Data received on the socket */
    ES_CLOSING                                        /**< Connection closing */
};

/**
 * \struct Keep track of TCP socket states.
 */
struct echo_state {
    uint8_t state;                              /**< echo_states socket state */
    uint8_t retries;                         /**< Number of retries attempted */
    struct tcp_pcb *pcb;                              /**< Connection context */
    struct pbuf *p;                              /**< pbuf (chain) to recycle */
};


/**
 * \brief LWIPMgr "class"
 */
/*${AOs::LWIPMgr} ..........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Local timer for LWIP slow tick. */
    QTimeEvt te_LWIP_SLOW_TICK;

    /**< Pointer to LWIP netif struct. */
    struct netif *netif;

    /**< Pointer to LWIP udp pcb struct. */
    struct udp_pcb *upcb;

    /**< IP address in the native host byte order. */
    uint32_t ip_addr;

    /**< LWIP native TCP timer.  Only exists if LWIP_TCP is defined. */
    #if LWIP_TCP
    uint32_t  tcp_tmr;
    #endif;

    /**< LWIP native ARP timer.  Only exists if LWIP_ARP is defined. */
    #if LWIP_ARP
    uint32_t  arp_tmr;
    #endif;

    /**< LWIP native DHCP fine timer.  Only exists if LWIP_DHCP is defined. */
    #if LWIP_DHCP
    uint32_t  dhcp_fine_tmr;
    #endif;

    /**< LWIP native DHCP coarse timer.  Only exists if LWIP_DHCP is defined. */
    #if LWIP_DHCP
    uint32_t  dhcp_coarse_tmr;
    #endif;

    /**< LWIP native AUTOIP coarse timer.  Only exists if LWIP_AUTOIP is defined. */
    #if LWIP_AUTOIP
    uint32_t  auto_ip_tmr;
    #endif;

    /**< Pointer to LWIP tcp pcb struct used to keep track of TCP connection to the
         system for commands and replies. */
    struct tcp_pcb *tpcb_sys;

    /**< Pointer to LWIP tcp pcb struct used to keep track of TCP connection to the
         system for logging. */
    struct tcp_pcb *tpcb_log;
} LWIPMgr;

/* protected: */
static QState LWIPMgr_initial(LWIPMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState LWIPMgr_Active(LWIPMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
#define LWIP_SLOW_TICK_MS       TCP_TMR_INTERVAL

/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static LWIPMgr l_LWIPMgr;       /* the single instance of the active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_LWIPMgr = (QActive *)&l_LWIPMgr;  /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/

/**
 * @brief: A callback function that handles acceptance of a connection
 * on an echo TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] *newpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_accept} ......................................................*/
static err_t echo_accept(
    void * arg,
    struct tcp_pcb * newpcb,
    err_t err
    );


/**
 * @brief: A callback function that handles the start of a RECV on the echo
 * TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] *newpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] *p: struct pbuf pointer to the LWIP pbuf that actually
 * contains the data received.
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_recv} ........................................................*/
static err_t echo_recv(
    void * arg,
    struct tcp_pcb * tpcb,
    struct pbuf * p,
    err_t err);


/**
 * @brief: A callback function that handles the errors on the echo TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return None
 */
/*${AOs::echo_error} .......................................................*/
static void echo_error(void * arg, err_t err);


/**
 * @brief: A callback function that handles the start of a RECV on the echo
 * TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_poll} ........................................................*/
static err_t echo_poll(void * arg, struct tcp_pcb * tpcb);


/**
 * @brief: A callback function that handles the start of a RECV on the echo
 * TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] len: uint16_t length of data sent.
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_sent} ........................................................*/
static err_t echo_sent(
    void * arg,
    struct tcp_pcb * tpcb,
    uint16_t len);


/**
 * @brief: A callback function that handles the actual sending of data
 * on an echo TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in|out] *es: echo_state struct to keep track of the socket state.
 *
 * @return None
 */
/*${AOs::echo_send} ........................................................*/
static void echo_send(struct tcp_pcb * tpcb, struct echo_state * es);


/**
 * @brief: A callback function that handles the closing the TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in|out] *es: echo_state struct to keep track of the socket state.
 *
 * @return None
 */
/*${AOs::echo_close} .......................................................*/
static void echo_close(struct tcp_pcb * tpcb, struct echo_state * es);



/* Private functions ---------------------------------------------------------*/
/**
  * @brief  This function is the UDP handler callback. It is automatically
  *             called by the LWIP stack when a new UDP message arrives.  It
  *             creates a new MsgEvt event (for CommStack) and publishes it to
  *             the shared CommStackMgr AO. IT SHOULD NOT BE CALLED DIRECTLY.
  *
  * @param  arg: a pointer to arg.  (Not currently used but in the original
  *             implementation of the callback.
  * @param  upcb: a pointer to the udb structure containing UDP connect data.
  * @param  p:  a pointer to the pbuf containing the received data.
  * @param  addr: a pointer to struct containing the IP data.
  * @param  part: a u16_t type containing the port number used to connect.
  * @retval None
  */
static void udp_rx_handler(void *arg, struct udp_pcb *upcb,
                           struct pbuf *p, struct ip_addr *addr, u16_t port);


/**
 * @brief C "constructor" for LWIP "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::LWIPMgr_ctor} .....................................................*/
void LWIPMgr_ctor(void) {
    LWIPMgr *me = &l_LWIPMgr;

    QActive_ctor(&me->super, (QStateHandler)&LWIPMgr_initial);
    QTimeEvt_ctor(&me->te_LWIP_SLOW_TICK, LWIP_SLOW_TICK_SIG);
}

/**
 * \brief LWIPMgr "class"
 */
/*${AOs::LWIPMgr} ..........................................................*/
/*${AOs::LWIPMgr::SM} ......................................................*/
static QState LWIPMgr_initial(LWIPMgr * const me, QEvt const * const e) {
    /* ${AOs::LWIPMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    uint8_t  macaddr[NETIF_MAX_HWADDR_LEN];

    QS_OBJ_DICTIONARY(&l_LWIPMgr);
    QS_OBJ_DICTIONARY(&l_LWIPMgr.te_LWIP_SLOW_TICK);

    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&LWIPMgr_initial);
    QS_FUN_DICTIONARY(&LWIPMgr_Active);
    QS_FUN_DICTIONARY(&udp_rx_handler);
    QS_FUN_DICTIONARY(&ETH_SendMsg_Handler);

    QS_FILTER_SM_OBJ(0);                  /* Turn off all tracing for this SM */
    QS_FILTER_AO_OBJ(0);                  /* Turn off all tracing for this AO */
    QS_FILTER_TE_OBJ(0);           /* Turn off time event tracing for this AO */

    /* Configure the hardware MAC address for the Ethernet Controller */

    /*
     * Set up the MAC address and make sure it's not all FF values
     * TODO: This will evetually be read somewhere
     */

    /* the MAC address must have been programmed! */
    Q_ASSERT((STATIC_IPADDR0 != 0xFF) &&
            (STATIC_IPADDR1 != 0xFF) &&
            (STATIC_IPADDR2 != 0xFF) &&
            (STATIC_IPADDR3 != 0xFF));

    macaddr[0] = DEF_MAC_ADDR0;
    macaddr[1] = DEF_MAC_ADDR1;
    macaddr[2] = DEF_MAC_ADDR2;
    macaddr[3] = DEF_MAC_ADDR3;
    macaddr[4] = DEF_MAC_ADDR4;
    macaddr[5] = DEF_MAC_ADDR5;

    DBG_printf("Static IP address: %d.%d.%d.%d\n",
          STATIC_IPADDR0, STATIC_IPADDR1, STATIC_IPADDR2, STATIC_IPADDR3);
    DBG_printf("MAC address: %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n",
          macaddr[0], macaddr[1],macaddr[2],macaddr[3],macaddr[4], macaddr[5]);

    me->ip_addr = 0xFFFFFFFF;               /* initialize to impossible value */
                                            /* initialize the Ethernet Driver */
    me->netif = eth_driver_init((QActive *)me, macaddr);

    /* Set up UDP related PCB */
    me->upcb = udp_new();
    udp_bind(me->upcb, IP_ADDR_ANY, 777);             /* use port 777 for UDP */
    udp_recv(me->upcb, &udp_rx_handler, me);

    /* Set up TCP related PCB */
    me->tpcb_sys = tcp_new();
    if (me->tpcb_sys == NULL) {
       ERR_printf("Unable to allocate LWIP memory for TCP\n");
    }
    err_t err = tcp_bind(me->tpcb_sys, IP_ADDR_ANY, 7778);   /* port 7778 for TCP */
    if (ERR_OK != err ) {
       ERR_printf("Unable to bind TCP to port 7778\n");
    }

    me->tpcb_sys = tcp_listen(me->tpcb_sys);
    tcp_accept(me->tpcb_sys, echo_accept);

    /* Second connection */
    me->tpcb_log = tcp_new();
    if (me->tpcb_log == NULL) {
       ERR_printf("Unable to allocate LWIP memory for TCP1\n");
    }
    err = tcp_bind(me->tpcb_log, IP_ADDR_ANY, 7779);   /* port 7779 for TCP */
    if (ERR_OK != err ) {
       ERR_printf("Unable to bind TCP to port 7779\n");
    }

    me->tpcb_log = tcp_listen(me->tpcb_log);
    tcp_accept(me->tpcb_log, echo_accept);

    QActive_subscribe((QActive *)me, ETH_SEND_SIG);
    return Q_TRAN(&LWIPMgr_Active);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::LWIPMgr::SM::Active} ..............................................*/
static QState LWIPMgr_Active(LWIPMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::LWIPMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            QTimeEvt_postEvery(
                &me->te_LWIP_SLOW_TICK,
                (QActive *)me,
                (LWIP_SLOW_TICK_MS * BSP_TICKS_PER_SEC) / 1000
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::LWIPMgr::SM::Active} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->te_LWIP_SLOW_TICK);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::LWIPMgr::SM::Active::ETH_SEND} */
        case ETH_SEND_SIG: {
            /* Event posted that will include (inside it) a msg to send */
            if (me->upcb->remote_port != (uint16_t)0) {
                struct pbuf *p = pbuf_new(
                    (u8_t *)((EthEvt const *)e)->msg,
                    ((EthEvt const *)e)->msg_len
                );
                if (p != (struct pbuf *)0) {
                    udp_send(me->upcb, p);
                    pbuf_free(p);                   /* don't leak the pbuf! */
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::LWIPMgr::SM::Active::LWIP_RX_READY} */
        case LWIP_RX_READY_SIG: {
            eth_driver_read();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::LWIPMgr::SM::Active::LWIP_TX_READY} */
        case LWIP_TX_READY_SIG: {
            eth_driver_write();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::LWIPMgr::SM::Active::LWIP_SLOW_TICK} */
        case LWIP_SLOW_TICK_SIG: {
            /* has IP address changed? */
            if (me->ip_addr != me->netif->ip_addr.addr) {
                uint32_t ip_net;    /* IP address in the network byte order */
                me->ip_addr = me->netif->ip_addr.addr; /* save the IP addr. */
                ip_net  = ntohl(me->ip_addr);
            }

            #if LWIP_TCP
            me->tcp_tmr += LWIP_SLOW_TICK_MS;
            if (me->tcp_tmr >= TCP_TMR_INTERVAL) {
                me->tcp_tmr = 0;
                tcp_tmr();
            }
            #endif

            #if LWIP_ARP
            me->arp_tmr += LWIP_SLOW_TICK_MS;
            if (me->arp_tmr >= ARP_TMR_INTERVAL) {
                me->arp_tmr = 0;
                etharp_tmr();
            }
            #endif

            #if LWIP_DHCP
            me->dhcp_fine_tmr += LWIP_SLOW_TICK_MS;
            if (me->dhcp_fine_tmr >= DHCP_FINE_TIMER_MSECS) {
                me->dhcp_fine_tmr = 0;
                dhcp_fine_tmr();
                if (me->netif->dhcp->state == DHCP_BOUND) {
                   DBG_printf("DHCP BOUND to addr: %d.%d.%d.%d\n",
                         ip4_addr1_16(&me->netif->dhcp->offered_ip_addr),
                         ip4_addr2_16(&me->netif->dhcp->offered_ip_addr),
                         ip4_addr3_16(&me->netif->dhcp->offered_ip_addr),
                         ip4_addr4_16(&me->netif->dhcp->offered_ip_addr)
                   );
                } else {
                   WRN_printf("DHCP NOT BOUND!\n");
                }
            }
            me->dhcp_coarse_tmr += LWIP_SLOW_TICK_MS;
            if (me->dhcp_coarse_tmr >= DHCP_COARSE_TIMER_MSECS) {
                me->dhcp_coarse_tmr = 0;
                dhcp_coarse_tmr();
            }
            #endif

            #if LWIP_AUTOIP
            me->auto_ip_tmr += LWIP_SLOW_TICK_MS;
            if (me->auto_ip_tmr >= AUTOIP_TMR_INTERVAL) {
                me->auto_ip_tmr = 0;
                autoip_tmr();
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::LWIPMgr::SM::Active::LWIP_RX_OVERRUN} */
        case LWIP_RX_OVERRUN_SIG: {
            LINK_STATS_INC(link.err);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}



/**
 * @brief: A callback function that handles acceptance of a connection
 * on an echo TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] *newpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_accept} ......................................................*/
static err_t echo_accept(
    void * arg,
    struct tcp_pcb * newpcb,
    err_t err
    )
{
    err_t ret_err;
    struct echo_state *es;

    LWIP_UNUSED_ARG(arg);
    LWIP_UNUSED_ARG(err);

    /* commonly observed practive to call tcp_setprio(), why? */
    tcp_setprio(newpcb, TCP_PRIO_MIN);

    es = (struct echo_state *)mem_malloc(sizeof(struct echo_state));
    if ( es != NULL ) {
        es->state = ES_ACCEPTED;
        es->pcb = newpcb;
        es->retries = 0;
        es->p = NULL;
        /* pass newly allocated es to our callbacks */
        tcp_arg(newpcb, es);
        tcp_recv(newpcb, echo_recv);
        tcp_err(newpcb, echo_error);
        tcp_poll(newpcb, echo_poll, 0);
        ret_err = ERR_OK;
        LOG_printf("New connection accepted\n");
    } else {
        ret_err = ERR_MEM;
        ERR_printf("Error allocating LWIP mem for echo state\n");
    }
    return ret_err;
}

/**
 * @brief: A callback function that handles the start of a RECV on the echo
 * TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] *newpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] *p: struct pbuf pointer to the LWIP pbuf that actually
 * contains the data received.
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_recv} ........................................................*/
static err_t echo_recv(
    void * arg,
    struct tcp_pcb * tpcb,
    struct pbuf * p,
    err_t err)
{
    struct echo_state *es;
    err_t ret_err;

    LWIP_ASSERT("arg != NULL",arg != NULL);
    es = (struct echo_state *)arg;
    if (p == NULL) {
        /* remote host closed connection */
        es->state = ES_CLOSING;
        if(es->p == NULL) {
            LOG_printf("Closing connection\n");
            /* we're done sending, close it */
            echo_close(tpcb, es);
        } else {
            /* we're not done yet */
            tcp_sent(tpcb, echo_sent);
            echo_send(tpcb, es);
        }
        ret_err = ERR_OK;

    } else if(err != ERR_OK) {
        /* cleanup, for unkown reason */
        if (p != NULL) {
            es->p = NULL;
            pbuf_free(p);
        }
        ret_err = err;
        ERR_printf("Unknown error\n");
    } else if(es->state == ES_ACCEPTED) {
        /* first data chunk in p->payload */
        es->state = ES_RECEIVED;
        /* store reference to incoming pbuf (chain) */
        es->p = p;
        /* install send completion notifier */
        tcp_sent(tpcb, echo_sent);
        echo_send(tpcb, es);
        ret_err = ERR_OK;
    } else if (es->state == ES_RECEIVED) {
        /* read some more data */
        if(es->p == NULL) {
            es->p = p;
            tcp_sent(tpcb, echo_sent);
            echo_send(tpcb, es);
        } else {
            struct pbuf *ptr;
             /* chain pbufs to the end of what we recv'ed previously  */
            ptr = es->p;
            pbuf_chain(ptr,p);
        }
        ret_err = ERR_OK;
    } else if(es->state == ES_CLOSING) {
        /* odd case, remote side closing twice, trash data */
        tcp_recved(tpcb, p->tot_len);
        es->p = NULL;
        pbuf_free(p);
        ret_err = ERR_OK;
    } else {
        /* unkown es->state, trash data  */
        tcp_recved(tpcb, p->tot_len);
        es->p = NULL;
        pbuf_free(p);
        ret_err = ERR_OK;
    }
    return ret_err;
}

/**
 * @brief: A callback function that handles the errors on the echo TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return None
 */
/*${AOs::echo_error} .......................................................*/
static void echo_error(void * arg, err_t err) {
    struct echo_state *es;
    LWIP_UNUSED_ARG(err);
    es = (struct echo_state *)arg;
    if (es != NULL) {
        mem_free(es);
    }
    ERR_printf("Handling error, freeing memory\n");
}

/**
 * @brief: A callback function that handles the start of a RECV on the echo
 * TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_poll} ........................................................*/
static err_t echo_poll(void * arg, struct tcp_pcb * tpcb) {
    err_t ret_err;
    struct echo_state *es;
    es = (struct echo_state *)arg;
    if (es != NULL) {
        if (es->p != NULL) {
            /* there is a remaining pbuf (chain)  */
            tcp_sent(tpcb, echo_sent);
            echo_send(tpcb, es);
        } else {
            /* no remaining pbuf (chain)  */
            if(es->state == ES_CLOSING) {
                echo_close(tpcb, es);
            }
        }
        ret_err = ERR_OK;
    } else {
        /* nothing to be done */
        tcp_abort(tpcb);
        ret_err = ERR_ABRT;
    }
    return ret_err;
}

/**
 * @brief: A callback function that handles the start of a RECV on the echo
 * TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] len: uint16_t length of data sent.
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */
/*${AOs::echo_sent} ........................................................*/
static err_t echo_sent(
    void * arg,
    struct tcp_pcb * tpcb,
    uint16_t len)
{
    struct echo_state *es;
    LWIP_UNUSED_ARG(len);
    es = (struct echo_state *)arg;
    es->retries = 0;
    if(es->p != NULL) {
        /* still got pbufs to send */
        tcp_sent(tpcb, echo_sent);
        echo_send(tpcb, es);
    } else {
        /* no more pbufs to send */
        if(es->state == ES_CLOSING) {
            echo_close(tpcb, es);
        }
    }
    return ERR_OK;
}

/**
 * @brief: A callback function that handles the actual sending of data
 * on an echo TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in|out] *es: echo_state struct to keep track of the socket state.
 *
 * @return None
 */
/*${AOs::echo_send} ........................................................*/
static void echo_send(struct tcp_pcb * tpcb, struct echo_state * es) {
    struct pbuf *ptr;
    err_t wr_err = ERR_OK;
    while ((wr_err == ERR_OK) && (es->p != NULL) && (es->p->len <= tcp_sndbuf(tpcb))) {
        ptr = es->p;
        /* enqueue data for transmission */
        wr_err = tcp_write(tpcb, ptr->payload, ptr->len, 1);
        if (wr_err == ERR_OK) {
            uint16_t plen;
            uint8_t freed;
            plen = ptr->len;

            /* continue with next pbuf in chain (if any) */
            es->p = ptr->next;
            if(es->p != NULL) {
                /* new reference! */
                pbuf_ref(es->p);
            }
            /* chop first pbuf from chain */
            do {
                /* try hard to free pbuf */
                freed = pbuf_free(ptr);
            } while(freed == 0);

            /* we can read more data now */
            tcp_recved(tpcb, plen);
        } else if(wr_err == ERR_MEM) {
            /* we are low on memory, try later / harder, defer to poll */
            es->p = ptr;
            WRN_printf("Running low on mem in LWIP, polling later\n");
        } else {
            /* other problem ?? */
            WRN_printf("Some unknown problem occurred\n");
        }
    }
}

/**
 * @brief: A callback function that handles the closing the TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in|out] *es: echo_state struct to keep track of the socket state.
 *
 * @return None
 */
/*${AOs::echo_close} .......................................................*/
static void echo_close(struct tcp_pcb * tpcb, struct echo_state * es) {
    tcp_arg(tpcb, NULL);
    tcp_sent(tpcb, NULL);
    tcp_recv(tpcb, NULL);
    tcp_err(tpcb, NULL);
    tcp_poll(tpcb, NULL, 0);

    if (es != NULL) {
        mem_free(es);
    }

    tcp_close(tpcb);
    LOG_printf("Connection closed\n");
}

/* Ethernet message sender ...................................................*/
void ETH_SendMsg_Handler(MsgEvt const *e) {

        /* 1. Construct a new msg event indicating that a msg has been received */
        EthEvt *ethEvt = Q_NEW(EthEvt, ETH_SEND_SIG);

        /* 2. Fill the msg payload with the message */
        MEMCPY(ethEvt->msg, e->msg, e->msg_len);
        ethEvt->msg_len = e->msg_len;

        /* 3. Publish the newly created EthEvt event to LWIPMgr AO */
        QF_PUBLISH((QEvent *)ethEvt, AO_LWIPMgr);
}

/* UDP handler ...............................................................*/
static void udp_rx_handler(void *arg, struct udp_pcb *upcb,
                           struct pbuf *p, struct ip_addr *addr, u16_t port) {

    /* 1. Construct a new msg event indicating that a msg has been received */
    MsgEvt *msgEvt = Q_NEW(MsgEvt, MSG_RECEIVED_SIG);

    /* 2. Fill the msg payload and get the msg source and length */
    MEMCPY(msgEvt->msg, p->payload, p->len);
    msgEvt->msg_len = p->len;

    /* 3. Don't bother publishing locally.  Instead, publish the newly created
     * MsgEvt event to CommStackMgr AO */
    QF_PUBLISH((QEvent *)msgEvt, AO_LWIPMgr);

    /* 4. connect to the remote host */
    udp_connect(upcb, addr, port);

    /* 5. Free up the pbuf */
    pbuf_free(p);
}

/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/
