<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="I2CDataEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for transporting I2C data.
 */</documentation>
   <attribute name="i2cDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device data is from. */</documentation>
   </attribute>
   <attribute name="bufData[MAX_MSG_LEN]" type="char" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data. */</documentation>
   </attribute>
   <attribute name="wDataLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in the buffer. */</documentation>
   </attribute>
   <attribute name="wAddr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Address on the I2C device read/written to. */</documentation>
   </attribute>
  </class>
  <class name="I2CEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for requesting I2C data reads and notifying of finished
 * writes.
 */</documentation>
   <attribute name="i2cBus" type="I2C_Bus_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C bus the event is for. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="I2CBusMgr" superclass="qpc::QActive">
   <documentation>/**
 * @brief I2CMgr Active Object (AO) &quot;class&quot; that manages the I2C bus.
 * This AO manages the I2C bus and all events associated with it. It
 * has exclusive access to the I2C bus and the ISR handlers will let
 * the AO know that the transfer has completed.  See I2CMgr.qm for
 * diagram and model.
 */</documentation>
   <attribute name="i2cTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout I2C transfers if errors occur. */</documentation>
   </attribute>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="iDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies which I2C device is currently being handled by this AO.  This should
     be set when a new I2C_READ_START or I2C_WRITE_START events come in.  Those
     events should contain the device for which they are meant for. */</documentation>
   </attribute>
   <attribute name="iBus" type="I2C_Bus_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C bus this AO is responsible for.  This variable is set on
     startup and is used to index into the structure that holds all the
     I2C bus settings. */</documentation>
   </attribute>
   <attribute name="nI2CLoopTimeout" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Counter used to manually timeout some I2C operations.  Though we supposed to
     not do blocking operations like this, it's unavoidable in this case since
     the I2C ISRs won't post events until they are cleared, which happens after
     here in the AO so nothing moves forward.  With all the delays introduced by
     just event handling, there should be no blocking in reality but just in case,
     there will still be timeout events launched from these loops if this counter
     gets to 0. */</documentation>
   </attribute>
   <attribute name="i2cDMATimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to time I2C DMA operations. */</documentation>
   </attribute>
   <attribute name="i2cCurrOperation" type="I2C_Operation_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies what the current I2C bus operation is happening.  Gets set upon
     reception of I2C_READ_START_SIG and I2C_WRITE_START_SIG */</documentation>
   </attribute>
   <attribute name="i2cRecoveryTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout I2C bus recovery wait states. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/0">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_I2CBusMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;I2CBusMgr_initial);
QS_FUN_DICTIONARY(&amp;I2CBusMgr_Active);
QS_FUN_DICTIONARY(&amp;I2CBusMgr_Idle);</action>
     <initial_glyph conn="1,2,4,3,14,4">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and 
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Post all the timers and disarm them right away so it can be
 * rearmed at any point without worrying asserts. */
QTimeEvt_postIn(
    &amp;me-&gt;i2cTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cDMATimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_READ_OP_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cDMATimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cRecoveryTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUS_RECOVERY_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cRecoveryTimerEvt);

/* Initialize the I2C devices and associated busses */
I2C_BusInit( me-&gt;iBus );</entry>
     <state name="Idle">
      <documentation>/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 * This state is the default rest state of the state machine and can handle
 * various I2C requests.  Upon entry, it also checks the deferred queue to see
 * if any request events are waiting which were posted while I2C bus was busy.
 * if there are any waiting, it will read them out, which automatically posts
 * them and the state machine will go and handle them.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* recall the request from the private requestQueue */
QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);

/* Clear out current operation */
me-&gt;i2cCurrOperation = I2C_OP_NONE;

DBG_printf(&quot;back in Idle\n&quot;);</entry>
      <state_glyph node="5,10,19,34">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,6,106,40">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="112,56"/>
   </statechart>
  </class>
  <attribute name="AO_I2CBusMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="I2CBusMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for I2CBusMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param  [in] i2cBus: I2C_TypeDef * type that specifies which STM32 I2C bus this
 * AO is responsible for.
 * @retval None
 */</documentation>
   <parameter name="iBus" type="I2C_Bus_t"/>
   <code>I2CBusMgr *me = &amp;l_I2CBusMgr;
me-&gt;iBus = iBus;

QActive_ctor( &amp;me-&gt;super, (QStateHandler)&amp;I2CBusMgr_initial );
QTimeEvt_ctor( &amp;me-&gt;i2cTimerEvt, I2C_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cDMATimerEvt, I2C_DMA_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cRecoveryTimerEvt, I2C_RECOVERY_TIMEOUT_SIG );

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);

dbg_slow_printf(&quot;Constructor\n&quot;);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="I2CBusMgr_gen.c">
   <text>/**
 * @file    I2CBusMgr.c
 * @brief   Declarations for functions for the I2CBusMgr AO.
 * This state machine handles all I/O on the I2C bus.  It can be instantiated
 * several times with a different bus for a parameter.  This AO doesn't handle
 * any actual I2C devices, just generic I2C bus operations such as sending the
 * start/end bit, waiting for events, initiating DMA reads/writes, etc.  I2C
 * devices should be handled in the I2CXDevMgr AOs.  This allows this AO to be
 * generic and reusable.
 *
 * @note 1: If editing this file, please make sure to update the I2CBusMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    10/24/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;I2CBusMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp.h&quot;          /* For seconds to bsp tick conversion (SEC_TO_TICK) */

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_I2C ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::I2CBusMgr)

/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static I2CBusMgr l_I2CBusMgr;     /* the single instance of the active object */

/* Global-scope objects ----------))------------------------------------------*/
QActive * const AO_I2CBusMgr = (QActive *)&amp;l_I2CBusMgr;/* &quot;opaque&quot; AO pointer */
extern I2C_BusSettings_t s_I2C_Bus[MAX_I2C_BUS];
extern I2C_BusDevice_t   s_I2C_Dev[MAX_I2C_DEV];

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::I2CBusMgr_ctor)
$define(AOs::I2CBusMgr)

/**
 * @} end addtogroup groupI2C
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="I2CBusMgr_gen.h">
   <text>/**
 * @file    I2CBusMgr.c
 * @brief   Declarations for functions for the I2CBusMgr AO.
 * This state machine handles all I/O on the I2C bus.  It can be instantiated
 * several times with a different bus for a parameter.  This AO doesn't handle
 * any actual I2C devices, just generic I2C bus operations such as sending the
 * start/end bit, waiting for events, initiating DMA reads/writes, etc.  I2C
 * devices should be handled in the I2CXDevMgr AOs.  This allows this AO to be
 * generic and reusable.
 *
 * @note 1: If editing this file, please make sure to update the I2CBusMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    10/24/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef I2CBUSMGR_H_
#define I2CBUSMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;                                   /*  Common Declarations */
#include &quot;i2c.h&quot;                               /* For I2C device declarations */

/* Exported defines ----------------------------------------------------------*/
#define MAX_BUS_RETRIES   100 /**&lt; Max number of retries for I2C bus for busy flag */
#define MAX_I2C_TIMEOUT 10000 /**&lt; Max number of retries for I2C bus for busy flag */
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::I2CBusMgr_ctor)
$declare(AOs::AO_I2CBusMgr)

/**
 * @} end addtogroup groupI2C
 */
#endif                                                        /* I2CBUSMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
