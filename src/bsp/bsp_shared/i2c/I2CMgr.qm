<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="I2CDataEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for transporting I2C data.
 */</documentation>
   <attribute name="buffer[MAX_MSG_LEN]" type="char" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data. */</documentation>
   </attribute>
   <attribute name="wBufferLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in the buffer. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="I2CMgr" superclass="qpc::QActive">
   <documentation>/**
 * @brief I2CMgr Active Object (AO) &quot;class&quot; that manages the I2C bus.
 * This AO manages the I2C bus and all events associated with it. It
 * has exclusive access to the I2C bus and the ISR handlers will let
 * the AO know that the transfer has completed.  See I2CMgr.qm for
 * diagram and model.
 */</documentation>
   <attribute name="i2cTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout I2C transfers if errors occur. */</documentation>
   </attribute>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="bBusBusy" type="FlagStatus" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Flag that indicates whether the bus is free or busy */</documentation>
   </attribute>
   <attribute name="i2cBusBusyTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to time retries for checking if the I2C bus is busy. */</documentation>
   </attribute>
   <attribute name="nBusRetries" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of number of retries used to check if the I2C bus is still busy. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/0">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_I2CMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;I2CMgr_initial);
QS_FUN_DICTIONARY(&amp;I2CMgr_Active);
QS_FUN_DICTIONARY(&amp;I2CMgr_Idle);
QS_FUN_DICTIONARY(&amp;I2CMgr_Busy);
QS_FUN_DICTIONARY(&amp;I2CMgr_Read);

QActive_subscribe((QActive *)me, I2C_READ_START_SIG);
QActive_subscribe((QActive *)me, I2C_WRITE_START_SIG);
QActive_subscribe((QActive *)me, I2C_TIMEOUT_SIG);
QActive_subscribe((QActive *)me, I2C_BUS_RETRY_TIMEOUT_SIG);</action>
     <initial_glyph conn="1,2,4,3,11,4">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and 
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Initialize the I2C devices and associated busses */
I2CD_Init( EEPROM );

/* Post all the timers and disarm them right away so it can be
 * rearmed at any point without worrying asserts. */
QTimeEvt_postIn(
    &amp;me-&gt;i2cTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cBusBusyTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_READ_OP_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cBusBusyTimerEvt);</entry>
     <state name="Idle">
      <documentation>/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* recall the request from the private requestQueue */
I2CDataEvt const *rq = (I2CDataEvt const *) (uint32_t) QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);

/* Reset all counters */
me-&gt;nBusRetries = 0;
DBG_printf(&quot;back in Idle\n&quot;);</entry>
      <tran trig="I2C_READ_START">
       <action>DBG_printf(&quot;Got I2C_READ_START\n&quot;);
me-&gt;bBusBusy = I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY);</action>
       <choice target="../../../1/2/0">
        <guard brief="else"/>
        <action>DBG_printf(&quot;Bus free\n&quot;);</action>
        <choice_glyph conn="49,15,5,0,36,2">
         <action box="1,-2,6,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../1/3">
        <guard brief="Bus busy?">SET == me-&gt;bBusBusy</guard>
        <action>/*Reset the retries counter when first getting into this state. */
me-&gt;nBusRetries = 0;
DBG_printf(&quot;Bus busy, waiting for free\n&quot;);</action>
        <choice_glyph conn="49,15,4,0,9">
         <action box="0,3,9,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="24,15,1,-1,25">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="5,8,19,39">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state name="Busy">
      <documentation>/**
 * @brief   This state indicates that the I2C is currently busy and cannot
 * process incoming data; incoming events will be deferred in this state and
 * handled once the AO goes back to Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUSY_SEC )
);
</entry>
      <exit>QTimeEvt_disarm( &amp;me-&gt;i2cTimerEvt ); /* Disarm timer on exit */</exit>
      <tran trig="I2C_TIMEOUT" target="../../0">
       <action>ERR_printf(&quot;I2C timeout occurred\n&quot;);</action>
       <tran_glyph conn="42,21,3,1,-18">
        <action box="-16,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C_READ_START, I2C_WRITE_START">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
} else {
   /* notify the request sender that the request was ignored.. */
   ERR_printf(&quot;Unable to defer I2C request\n&quot;);
}</action>
       <tran_glyph conn="42,68,3,-1,16">
        <action box="0,-4,15,4"/>
       </tran_glyph>
      </tran>
      <state name="BusBeingUsed">
       <entry>/* Send START condition */
I2C_GenerateSTART(I2C1, ENABLE);
DBG_printf(&quot;Generating I2C start\n&quot;);</entry>
       <state name="Read">
        <state_glyph node="81,17,22,14"/>
       </state>
       <state name="WaitForBusMasterAck">
        <state_glyph node="88,38,24,24"/>
       </state>
       <state_glyph node="77,11,43,57">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitForBusFree">
       <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUS_BUSY_RETRY_SEC )
);
</entry>
       <tran trig="I2C_BUS_RETRY_TIMEOUT">
        <action>me-&gt;nBusRetries++;
me-&gt;bBusBusy = I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY);</action>
        <choice target="../../../2">
         <guard>else</guard>
         <choice_glyph conn="49,37,5,3,28">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="Bus Busy?">SET == me-&gt;bBusBusy</guard>
         <choice target="../../..">
          <guard brief="Retries left?">MAX_BUS_RETRIES &gt; me-&gt;nBusRetries</guard>
          <choice_glyph conn="38,37,4,3,-9,9">
           <action box="-8,-11,11,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <choice_glyph conn="38,37,5,1,-14">
           <action box="-8,-2,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="49,37,5,-1,-11">
          <action box="-10,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,30,2,-1,7">
         <action box="0,0,22,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="47,24,21,6">
        <entry box="1,2,4,2"/>
       </state_glyph>
      </state>
      <state_glyph node="42,8,82,62">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,3,122,70">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="128,75"/>
   </statechart>
  </class>
  <attribute name="AO_I2CMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="I2CMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for I2CMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param  None
 * @param  None
 * @retval None
 */</documentation>
   <code>I2CMgr *me = &amp;l_I2CMgr;
QActive_ctor( &amp;me-&gt;super, (QStateHandler)&amp;I2CMgr_initial );
QTimeEvt_ctor( &amp;me-&gt;i2cTimerEvt, I2C_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cBusBusyTimerEvt, I2C_BUS_RETRY_TIMEOUT_SIG );

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);

dbg_slow_printf(&quot;Constructor\n&quot;);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="I2CMgr_gen.c">
   <text>/**
 * @file    I2CMgr.c
 * @brief   Declarations for functions for the I2CMgr AO.
 * This state machine handles all I/O on the I2C bus.
 *
 * @note 1: If editing this file, please make sure to update the I2CMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    07/01/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;I2CMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp.h&quot;          /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include &quot;i2c.h&quot;

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::I2CMgr)

/* Private defines -----------------------------------------------------------*/
#define MAX_BUS_RETRIES    10 /**&lt; Max number of retries for I2C bus for busy flag */
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static I2CMgr l_I2CMgr;           /* the single instance of the active object */

/* Global-scope objects ----------))------------------------------------------*/
QActive * const AO_I2CMgr = (QActive *)&amp;l_I2CMgr;      /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::I2CMgr_ctor)
$define(AOs::I2CMgr)

/**
 * @} end addtogroup groupI2C
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="I2CMgr_gen.h">
   <text>/**
 * @file    I2CMgr.h
 * @brief   Declarations for functions for the I2CMgr AO.
 * This state machine handles all I/O on the I2C bus.
 *
 * @note 1: If editing this file, please make sure to update the I2CMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    07/01/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef I2CMGR_H_
#define I2CMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;                                   /*  Common Declarations */

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::I2CMgr_ctor)
$declare(AOs::AO_I2CMgr)

/**
 * @} end addtogroup groupI2C
 */
#endif                                                           /* I2CMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
