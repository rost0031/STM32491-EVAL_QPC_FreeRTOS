<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="I2CDataEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for transporting I2C data.
 */</documentation>
   <attribute name="i2cDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device data is from. */</documentation>
   </attribute>
   <attribute name="buffer[MAX_MSG_LEN]" type="char" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data. */</documentation>
   </attribute>
   <attribute name="wBufferLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in the buffer. */</documentation>
   </attribute>
  </class>
  <class name="I2CReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for requesting I2C data.
 */</documentation>
   <attribute name="i2cDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device is being accessed. */</documentation>
   </attribute>
   <attribute name="wReadAddr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Address on the I2C device to read. */</documentation>
   </attribute>
   <attribute name="nReadLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Number of bytes to read from I2C device. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="I2CMgr" superclass="qpc::QActive">
   <documentation>/**
 * @brief I2CMgr Active Object (AO) &quot;class&quot; that manages the I2C bus.
 * This AO manages the I2C bus and all events associated with it. It
 * has exclusive access to the I2C bus and the ISR handlers will let
 * the AO know that the transfer has completed.  See I2CMgr.qm for
 * diagram and model.
 */</documentation>
   <attribute name="i2cTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout I2C transfers if errors occur. */</documentation>
   </attribute>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="bBusBusy" type="FlagStatus" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Flag that indicates whether the bus is free or busy */</documentation>
   </attribute>
   <attribute name="i2cBusBusyTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to time retries for checking if the I2C bus is busy. */</documentation>
   </attribute>
   <attribute name="nBusRetries" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of number of retries used to check if the I2C bus is still busy. */</documentation>
   </attribute>
   <attribute name="wAddr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Address on the I2C device to read or write to.  This will be used to store
 the address coming from the events. */</documentation>
   </attribute>
   <attribute name="iDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies which I2C device is currently being handled by this AO.  This should
     be set when a new I2C_READ_START or I2C_WRITE_START events come in.  Those
     events should contain the device for which they are meant for. */</documentation>
   </attribute>
   <attribute name="i2cBus" type="I2C_TypeDef *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which STM32 I2C bus this AO is responsible for.  This variable is set on 
     startup and should be used any time that a function from stm32f2xx_i2c.* is
     called. */</documentation>
   </attribute>
   <attribute name="nI2CLoopTimeout" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Counter used to manually timeout some I2C operations.  Though we supposed to
     not do blocking operations like this, it's unavoidable in this case since
     the I2C ISRs won't post events until they are cleared, which happens after
     here in the AO so nothing moves forward.  With all the delays introduced by
     just event handling, there should be no blocking in reality but just in case,
     there will still be timeout events launched from these loops if this counter
     gets to 0. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/0">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_I2CMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;I2CMgr_initial);
QS_FUN_DICTIONARY(&amp;I2CMgr_Active);
QS_FUN_DICTIONARY(&amp;I2CMgr_Idle);
QS_FUN_DICTIONARY(&amp;I2CMgr_Busy);
QS_FUN_DICTIONARY(&amp;I2CMgr_Read);

QActive_subscribe((QActive *)me, I2C_READ_START_SIG);
QActive_subscribe((QActive *)me, I2C_WRITE_START_SIG);
QActive_subscribe((QActive *)me, I2C_TIMEOUT_SIG);
QActive_subscribe((QActive *)me, I2C_BUS_RETRY_TIMEOUT_SIG);
QActive_subscribe((QActive *)me, I2C_MSTR_MODE_SELECTED_SIG);
QActive_subscribe((QActive *)me, I2C_MSTR_BYTE_TRANSMITTED_SIG);</action>
     <initial_glyph conn="1,2,4,3,11,4">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and 
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Post all the timers and disarm them right away so it can be
 * rearmed at any point without worrying asserts. */
QTimeEvt_postIn(
    &amp;me-&gt;i2cTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cBusBusyTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_READ_OP_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cBusBusyTimerEvt);

/* Initialize the I2C devices and associated busses */
I2C_BusInit( I2CBus1 );</entry>
     <state name="Idle">
      <documentation>/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* recall the request from the private requestQueue */
I2CDataEvt const *rq = (I2CDataEvt const *) (uint32_t) QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);

/* Reset all counters */
me-&gt;nBusRetries = 0;
DBG_printf(&quot;back in Idle\n&quot;);</entry>
      <tran trig="I2C_READ_START">
       <action>DBG_printf(&quot;Got I2C_READ_START\n&quot;);

/* Store the device */
me-&gt;iDevice = ((I2CReqEvt const *)e)-&gt;i2cDevice;

/* Store the address */
me-&gt;wAddr = ((I2CReqEvt const *)e)-&gt;wReadAddr;

//I2C_SoftwareResetCmd(I2C1, ENABLE);
//I2C_SoftwareResetCmd(I2C1, DISABLE);

/* Check if the bus is busy */
me-&gt;bBusBusy = I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY);</action>
       <choice target="../../../1/2/1">
        <guard brief="else"/>
        <action>DBG_printf(&quot;Bus free\n&quot;);</action>
        <choice_glyph conn="49,15,5,3,32">
         <action box="1,-2,6,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../1/3">
        <guard brief="Bus busy?">SET == me-&gt;bBusBusy</guard>
        <action>/*Reset the retries counter when first getting into this state. */
me-&gt;nBusRetries = 0;
DBG_printf(&quot;Bus busy, waiting for free\n&quot;);</action>
        <choice_glyph conn="49,15,4,0,9">
         <action box="0,3,9,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="24,15,1,-1,25">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="5,8,19,39">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state name="Busy">
      <documentation>/**
 * @brief   This state indicates that the I2C is currently busy and cannot
 * process incoming data; incoming events will be deferred in this state and
 * handled once the AO goes back to Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUSY_SEC )
);
</entry>
      <exit>QTimeEvt_disarm( &amp;me-&gt;i2cTimerEvt ); /* Disarm timer on exit */</exit>
      <tran trig="I2C_TIMEOUT" target="../../0">
       <action>ERR_printf(&quot;I2C timeout occurred\n&quot;);</action>
       <tran_glyph conn="42,21,3,1,-18">
        <action box="-16,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C_READ_START, I2C_WRITE_START">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
} else {
   /* notify the request sender that the request was ignored.. */
   ERR_printf(&quot;Unable to defer I2C request\n&quot;);
}</action>
       <tran_glyph conn="42,68,3,-1,16">
        <action box="0,-4,15,4"/>
       </tran_glyph>
      </tran>
      <state name="BusBeingUsed">
       <entry>DBG_printf(&quot;Generating I2C start\n&quot;);

/* Send START condition */
I2C_GenerateSTART(me-&gt;i2cBus, ENABLE);

/* Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;
while( !I2C_CheckEvent(me-&gt;i2cBus, I2C_EVENT_MASTER_MODE_SELECT) ) {
    if((me-&gt;nI2CLoopTimeout--) == 0) {
        ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_MODE_SELECT\n&quot;);
        /* Post a timeout event to get out */
        QEvt *qEvt = Q_NEW(QEvt, I2C_TIMEOUT_SIG);
        QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
        break; /* Break out of the state so the event can get handled */
    }
}</entry>
       <exit>I2C_GenerateSTOP(I2C1, ENABLE);
DBG_printf(&quot;Generating I2C stop\n&quot;);</exit>
       <state name="Read">
        <entry>/* Set the direction to receive */
I2C_SetDirection( I2CBus1,  I2C_Direction_Receiver);

DBG_printf(&quot;Generating I2C start for READ\n&quot;);
/* Send START condition */
I2C_GenerateSTART(I2C1, ENABLE);</entry>
        <tran trig="I2C_MSTR_MODE_SELECTED">
         <action>DBG_printf(&quot;Got I2C_MSTR_MODE_SELECTED for READ\n&quot;);</action>
         <tran_glyph conn="81,37,3,-1,3,1">
          <action box="0,-2,22,2"/>
         </tran_glyph>
        </tran>
        <tran trig="I2C_READ_DONE" target="../../../../0">
         <action>DBG_printf(&quot;Read finished successfully\n&quot;);</action>
         <tran_glyph conn="81,41,3,1,-49,1,-8">
          <action box="-28,-2,19,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="81,31,29,20">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="SelectI2CDevice">
        <entry>DBG_printf(&quot;Selecting slave I2C Device\n&quot;);

/* Send slave Address for write */
I2C_Send7bitAddress(
    me-&gt;i2cBus,                            /* This is always the bus used in this ISR */
    s_I2C_Bus[I2CBus1].i2c_cur_dev_addr,   /* Look up the current device address for this bus */
    s_I2C_Bus[I2CBus1].bTransDirection     /* Direction of data on this bus */
);

/* Test on EV6 and clear it */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;
while( !I2C_CheckEvent(me-&gt;i2cBus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ) {
    if((me-&gt;nI2CLoopTimeout--) == 0) {
        ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED\n&quot;);
        /* Post a timeout event to get out */
        QEvt *qEvt = Q_NEW(QEvt, I2C_TIMEOUT_SIG);
        QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
        break; /* Break out of the state so the event can get handled */
    }
}

DBG_printf(&quot;Selecting device took %d iterations\n&quot;, me-&gt;nI2CLoopTimeout);

/* Send the MSB of the address first to the I2C device */
I2C_SendData(I2C1, (uint8_t)((me-&gt;wAddr &amp; 0xFF00) &gt;&gt; 8));

/* Test on EV8 and clear it */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;
while( !I2C_CheckEvent(me-&gt;i2cBus, I2C_EVENT_MASTER_BYTE_TRANSMITTED) ) {
    if((me-&gt;nI2CLoopTimeout--) == 0) {
        ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_BYTE_TRANSMITTED for MSB\n&quot;);
        /* Post a timeout event to get out */
        QEvt *qEvt = Q_NEW(QEvt, I2C_TIMEOUT_SIG);
        QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
        break; /* Break out of the state so the event can get handled */
    }
}

DBG_printf(&quot;Sending MSB took %d iterations\n&quot;, me-&gt;nI2CLoopTimeout);

/* Send the LSB of the address to the I2C device second */
DBG_printf(&quot;Sending LSB of addr: %x\n&quot;, (uint8_t)((me-&gt;wAddr &amp; 0xFF00) &gt;&gt; 8));
I2C_SendData(me-&gt;i2cBus, (uint8_t)((me-&gt;wAddr &amp; 0x00FF) &gt;&gt; 8));

/* Test on EV8 and clear it */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;
while( !I2C_CheckEvent(me-&gt;i2cBus, I2C_EVENT_MASTER_BYTE_TRANSMITTED) ) {
    if((me-&gt;nI2CLoopTimeout--) == 0) {
        ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_BYTE_TRANSMITTED for LSB\n&quot;);
        /* Post a timeout event to get out */
        QEvt *qEvt = Q_NEW(QEvt, I2C_TIMEOUT_SIG);
        QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
        break; /* Break out of the state so the event can get handled */
    }
}

DBG_printf(&quot;Sending LSB took %d iterations\n&quot;, me-&gt;nI2CLoopTimeout);

/* If we got here, then everything went ok and we can move on.  Post an event
 * to do so. */
QEvt *qEvt = Q_NEW(QEvt, I2C_MSTR_BYTE_TRANSMITTED_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
        <tran trig="I2C_MSTR_BYTE_TRANSMITTED" target="../../0">
         <action>DBG_printf(&quot;Got I2C_MSTR_BYTE_TRANSMITTED after LSB\n&quot;);</action>
         <tran_glyph conn="83,20,2,0,7,0,4">
          <action box="0,1,27,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="81,14,14,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="74,11,46,57">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitForBusFree">
       <entry>/* Post a timer on entry */
//QTimeEvt_rearm(
//    &amp;me-&gt;i2cTimerEvt,
//    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUS_BUSY_RETRY_SEC )
//);

/* Create MsgEvt event to send out the message */
QEvt *qEvt = Q_NEW(QEvt, I2C_BUS_RETRY_TIMEOUT_SIG);

/* Post the msgEvt for this AO (CommStackMgr) to handle */
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
       <tran trig="I2C_BUS_RETRY_TIMEOUT">
        <action>me-&gt;nBusRetries++;

I2C_SoftwareResetCmd(I2C1, ENABLE);
I2C_SoftwareResetCmd(I2C1, DISABLE);
DBG_printf(&quot;Reset bus\n&quot;);

me-&gt;bBusBusy = I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY);</action>
        <choice target="../../../2">
         <guard>else</guard>
         <action>DBG_printf(&quot;Bus free after %d retries\n&quot;, me-&gt;nBusRetries);</action>
         <choice_glyph conn="49,37,5,3,22,-20,3">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="Bus Busy?">SET == me-&gt;bBusBusy</guard>
         <action>DBG_printf(&quot;Bus still busy after %d retries\n&quot;, me-&gt;nBusRetries);</action>
         <choice target="../../..">
          <guard brief="Retries left?">MAX_BUS_RETRIES &gt; me-&gt;nBusRetries</guard>
          <action>DBG_printf(&quot;Retrying\n&quot;);</action>
          <choice_glyph conn="38,37,4,3,-9,9">
           <action box="-8,-11,11,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <action>DBG_printf(&quot;Out of retries\n&quot;);</action>
          <choice_glyph conn="38,37,5,1,-14">
           <action box="-8,-2,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="49,37,5,-1,-11">
          <action box="-10,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,30,2,-1,7">
         <action box="0,0,22,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="47,24,21,6">
        <entry box="1,2,4,2"/>
       </state_glyph>
      </state>
      <state_glyph node="42,8,82,62">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,3,122,70">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="128,75"/>
   </statechart>
  </class>
  <attribute name="AO_I2CMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="I2CMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for I2CMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param  [in] i2cBus: I2C_TypeDef * type that specifies which STM32 I2C bus this
 * AO is responsible for.
 * @retval None
 */</documentation>
   <parameter name="i2cBus" type="I2C_TypeDef *  "/>
   <code>I2CMgr *me = &amp;l_I2CMgr;
me-&gt;i2cBus = i2cBus;

QActive_ctor( &amp;me-&gt;super, (QStateHandler)&amp;I2CMgr_initial );
QTimeEvt_ctor( &amp;me-&gt;i2cTimerEvt, I2C_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cBusBusyTimerEvt, I2C_BUS_RETRY_TIMEOUT_SIG );

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);

dbg_slow_printf(&quot;Constructor\n&quot;);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="I2CMgr_gen.c">
   <text>/**
 * @file    I2CMgr.c
 * @brief   Declarations for functions for the I2CMgr AO.
 * This state machine handles all I/O on the I2C bus.
 *
 * @note 1: If editing this file, please make sure to update the I2CMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    07/01/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;I2CMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp.h&quot;          /* For seconds to bsp tick conversion (SEC_TO_TICK) */

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::I2CMgr)

/* Private defines -----------------------------------------------------------*/
#define MAX_BUS_RETRIES    10 /**&lt; Max number of retries for I2C bus for busy flag */
#define MAX_I2C_TIMEOUT 0xF00 /**&lt; Max number of retries for I2C bus for busy flag */
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static I2CMgr l_I2CMgr;           /* the single instance of the active object */

/* Global-scope objects ----------))------------------------------------------*/
QActive * const AO_I2CMgr = (QActive *)&amp;l_I2CMgr;      /* &quot;opaque&quot; AO pointer */
extern I2C_BusSettings_t s_I2C_Bus[MAX_I2C_BUS];

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::I2CMgr_ctor)
$define(AOs::I2CMgr)

/**
 * @} end addtogroup groupI2C
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="I2CMgr_gen.h">
   <text>/**
 * @file    I2CMgr.h
 * @brief   Declarations for functions for the I2CMgr AO.
 * This state machine handles all I/O on the I2C bus.
 *
 * @note 1: If editing this file, please make sure to update the I2CMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    07/01/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef I2CMGR_H_
#define I2CMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;                                   /*  Common Declarations */
#include &quot;i2c.h&quot;                               /* For I2C device declarations */

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::I2CMgr_ctor)
$declare(AOs::AO_I2CMgr)

/**
 * @} end addtogroup groupI2C
 */
#endif                                                           /* I2CMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
