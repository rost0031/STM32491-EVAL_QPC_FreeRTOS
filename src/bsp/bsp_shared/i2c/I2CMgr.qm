<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="I2CDataEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for transporting I2C data.
 */</documentation>
   <attribute name="i2cDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device data is from. */</documentation>
   </attribute>
   <attribute name="bufData[MAX_MSG_LEN]" type="char" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data. */</documentation>
   </attribute>
   <attribute name="wDataLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in the buffer. */</documentation>
   </attribute>
   <attribute name="wAddr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Address on the I2C device read/written to. */</documentation>
   </attribute>
  </class>
  <class name="I2CEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for requesting I2C data reads and notifying of finished
 * writes.
 */</documentation>
   <attribute name="i2cDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device is being accessed. */</documentation>
   </attribute>
   <attribute name="wAddr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Address on the I2C device. */</documentation>
   </attribute>
   <attribute name="wDataLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Number of bytes to read/written from I2C device. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="I2CMgr" superclass="qpc::QActive">
   <documentation>/**
 * @brief I2CMgr Active Object (AO) &quot;class&quot; that manages the I2C bus.
 * This AO manages the I2C bus and all events associated with it. It
 * has exclusive access to the I2C bus and the ISR handlers will let
 * the AO know that the transfer has completed.  See I2CMgr.qm for
 * diagram and model.
 */</documentation>
   <attribute name="i2cTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout I2C transfers if errors occur. */</documentation>
   </attribute>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="iDevice" type="I2C_Device_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies which I2C device is currently being handled by this AO.  This should
     be set when a new I2C_READ_START or I2C_WRITE_START events come in.  Those
     events should contain the device for which they are meant for. */</documentation>
   </attribute>
   <attribute name="iBus" type="I2C_Bus_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C bus this AO is responsible for.  This variable is set on
     startup and is used to index into the structure that holds all the
     I2C bus settings. */</documentation>
   </attribute>
   <attribute name="nI2CLoopTimeout" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Counter used to manually timeout some I2C operations.  Though we supposed to
     not do blocking operations like this, it's unavoidable in this case since
     the I2C ISRs won't post events until they are cleared, which happens after
     here in the AO so nothing moves forward.  With all the delays introduced by
     just event handling, there should be no blocking in reality but just in case,
     there will still be timeout events launched from these loops if this counter
     gets to 0. */</documentation>
   </attribute>
   <attribute name="i2cDMATimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to time I2C DMA operations. */</documentation>
   </attribute>
   <attribute name="i2cCurrOperation" type="I2C_Operation_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies what the current I2C bus operation is happening.  Gets set upon
     reception of I2C_READ_START_SIG and I2C_WRITE_START_SIG */</documentation>
   </attribute>
   <attribute name="i2cRecoveryTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout I2C bus recovery wait states. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/1">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_I2CMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;I2CMgr_initial);
QS_FUN_DICTIONARY(&amp;I2CMgr_Active);
QS_FUN_DICTIONARY(&amp;I2CMgr_Idle);
QS_FUN_DICTIONARY(&amp;I2CMgr_Busy);
QS_FUN_DICTIONARY(&amp;I2CMgr_Read);

QActive_subscribe((QActive *)me, I2C_READ_START_SIG);
QActive_subscribe((QActive *)me, I2C_WRITE_START_SIG);
QActive_subscribe((QActive *)me, I2C_TIMEOUT_SIG);
QActive_subscribe((QActive *)me, I2C_CHECK_EV_SIG);
QActive_subscribe((QActive *)me, I2C_READ_DONE_SIG);
QActive_subscribe((QActive *)me, I2C_WRITE_DONE_SIG);
QActive_subscribe((QActive *)me, I2C_DMA_TIMEOUT_SIG);
QActive_subscribe((QActive *)me, I2C_EV_MASTER_MODE_SELECT_SIG);
QActive_subscribe((QActive *)me, I2C_EV_MASTER_TX_MODE_SELECTED_SIG);
QActive_subscribe((QActive *)me, I2C_SENT_MSB_ADDR_SIG);
QActive_subscribe((QActive *)me, I2C_SENT_LSB_ADDR_SIG);
QActive_subscribe((QActive *)me, I2C_RECOVERY_TIMEOUT_SIG);</action>
     <initial_glyph conn="1,2,4,3,14,4">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and 
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Post all the timers and disarm them right away so it can be
 * rearmed at any point without worrying asserts. */
QTimeEvt_postIn(
    &amp;me-&gt;i2cTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cDMATimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_READ_OP_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cDMATimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cRecoveryTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUS_RECOVERY_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;i2cRecoveryTimerEvt);

/* Initialize the I2C devices and associated busses */
I2C_BusInit( me-&gt;iBus );</entry>
     <state name="Busy">
      <documentation>/**
 * @brief   This state indicates that the I2C is currently busy and cannot
 * process incoming data; incoming events will be deferred in this state and
 * handled once the AO goes back to Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUSY_SEC )
);

/* Set the I2C device state */
s_I2C_Bus[me-&gt;iBus].i2c_cur_st = I2C_IDLE_ST;</entry>
      <exit>QTimeEvt_disarm( &amp;me-&gt;i2cTimerEvt ); /* Disarm timer on exit */</exit>
      <tran trig="I2C_TIMEOUT" target="../../1">
       <action>ERR_printf(&quot;I2C timeout occurred\n&quot;);</action>
       <tran_glyph conn="40,35,3,1,-16">
        <action box="-13,-2,13,2"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C_READ_START, I2C_WRITE_START">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
   DBG_printf(&quot;Deferring I2C request until current is done\n&quot;);
} else {
   /* notify the request sender that the request was ignored.. */
   ERR_printf(&quot;Unable to defer I2C request\n&quot;);
}</action>
       <tran_glyph conn="40,177,3,-1,16">
        <action box="0,-4,15,4"/>
       </tran_glyph>
      </tran>
      <state name="WaitForBusRecovery">
       <entry>/* Set the pins up for manual toggling */
I2C_BusInitForRecovery( me-&gt;iBus );

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;

WRN_printf(&quot;Some I2C%d slave device is misbehaving.\n&quot;, (me-&gt;iBus) + 1);
WRN_printf(&quot;Attempting to recover bus by toggling the SCL line\n&quot;);
WRN_printf(&quot;This may cause data corruption if the last I2C op was a write\n&quot;);</entry>
       <exit>/* Initialize the I2C devices and associated busses */
LOG_printf(&quot;ReInitializing I2C%d bus.\n&quot;, (me-&gt;iBus) + 1);
I2C_BusInit( me-&gt;iBus );</exit>
       <state name="TogglingSCL">
        <entry>/* Toggle the SCL bit of the bus to the opposite value that it is now */
GPIO_ToggleBits( s_I2C_Bus[me-&gt;iBus].scl_port, s_I2C_Bus[me-&gt;iBus].scl_pin );

/* Create event to check event and publish it */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
        <tran trig="I2C_CHECK_EV">
         <action>/* Check if bus is busy.  If free, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
         <choice target="../../../../7">
          <guard brief="Bus Free?">SET == GPIO_ReadInputDataBit( s_I2C_Bus[me-&gt;iBus].sda_port, s_I2C_Bus[me-&gt;iBus].sda_pin  )</guard>
          <action>WRN_printf(&quot;Bus free after %d SCL toggles\n&quot;, MAX_I2C_TIMEOUT - me-&gt;nI2CLoopTimeout);

/* Make sure to leave the SCL line high after exit */
GPIO_SetBits( s_I2C_Bus[me-&gt;iBus].scl_port, s_I2C_Bus[me-&gt;iBus].scl_pin );

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
          <choice_glyph conn="91,44,5,2,53,-9">
           <action box="0,1,14,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="else"/>
          <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
          <choice target="../../..">
           <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
           <choice_glyph conn="80,44,4,2,-4">
            <action box="-11,-4,12,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard brief="else"/>
           <action>ERR_printf(&quot;Timeout waiting for I2C bus to be free\n&quot;);
I2C_SoftwareResetCmd(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);
I2C_SoftwareResetCmd(s_I2C_Bus[me-&gt;iBus].i2c_bus, DISABLE);
DBG_printf(&quot;I2C bus reset\n&quot;);</action>
           <choice_glyph conn="80,44,5,1,-56">
            <action box="-7,0,6,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="91,44,5,-1,-11">
           <action box="-7,0,6,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="91,40,2,-1,4">
          <action box="0,0,14,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="74,34,19,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="68,28,37,19">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="BusBeingUsed">
       <entry>DBG_printf(&quot;Generating I2C start\n&quot;);

/* Send START condition */
I2C_GenerateSTART(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);</entry>
       <state name="WaitFor_I2C_EV6">
        <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
        <tran trig="I2C_CHECK_EV">
         <action>/* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
         <choice>
          <guard brief="EV6 Happened?">I2C_CheckEvent( s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED )</guard>
          <action>/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
          <choice target="../../../../4">
           <guard brief="2 Byte addr?">2 == I2C_getDevAddrSize(me-&gt;iDevice)</guard>
           <action brief="Send MSB of Addr">DBG_printf(&quot;Sending internal MSB addr to the I2C Device\n&quot;);

/* Send the MSB of the address first to the I2C device */
I2C_SendData(
    s_I2C_Bus[me-&gt;iBus].i2c_bus,
    (uint8_t)((s_I2C_Dev[me-&gt;iDevice].i2c_mem_addr &amp; 0xFF00) &gt;&gt; 8)
);
</action>
           <choice_glyph conn="88,76,5,1,-24">
            <action box="-14,-2,13,4"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../5">
           <guard brief="1 byte addr?">else</guard>
           <action brief="Send entire addr">DBG_printf(&quot;Sending internal 1 byte addr to the I2C Device\n&quot;);

/* Send the single byte address to the device */
I2C_SendData(
    s_I2C_Bus[me-&gt;iBus].i2c_bus,
    (uint8_t)(s_I2C_Dev[me-&gt;iDevice].i2c_mem_addr &amp; 0x00FF)
);</action>
           <choice_glyph conn="88,76,4,1,16,-23">
            <action box="-14,12,13,4"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="88,69,4,-1,7">
           <action box="0,2,14,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="else"/>
          <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
          <choice target="../../..">
           <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
           <choice_glyph conn="77,69,4,2,-4">
            <action box="0,-3,11,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard brief="else"/>
           <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n&quot;);</action>
           <choice_glyph conn="77,69,5,1,-53">
            <action box="-8,0,7,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="88,69,5,-1,-11">
           <action box="-7,0,6,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="88,65,2,-1,4">
          <action box="0,0,14,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="74,59,18,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="SetupI2CDevice">
        <entry>/* Set the I2C device state: generate start bit */
s_I2C_Bus[me-&gt;iBus].i2c_cur_st = I2C_GEN_START_ST;

/* Set the direction to transmit the address */
I2C_SetDirection( me-&gt;iBus,  I2C_Direction_Transmitter);</entry>
        <tran trig="I2C_EV_MASTER_MODE_SELECT">
         <action>DBG_printf(&quot;Got I2C_EV_MASTER_MODE_SELECT\n&quot;);</action>
         <tran_glyph conn="114,60,3,-1,28">
          <action box="0,-2,24,2"/>
         </tran_glyph>
        </tran>
        <tran trig="I2C_EV_MASTER_TX_MODE_SELECTED">
         <action>DBG_printf(&quot;Got I2C_EV_MASTER_TX_MODE_SELECTED\n&quot;);</action>
         <tran_glyph conn="114,63,3,-1,28">
          <action box="0,-2,30,2"/>
         </tran_glyph>
        </tran>
        <tran trig="I2C_SENT_MSB_ADDR">
         <action>DBG_printf(&quot;Got I2C_SENT_MSB_ADDR\n&quot;);</action>
         <tran_glyph conn="114,66,3,-1,28">
          <action box="0,-2,19,2"/>
         </tran_glyph>
        </tran>
        <tran trig="I2C_SENT_LSB_ADDR">
         <action>DBG_printf(&quot;Got I2C_SENT_LSB_ADDR\n&quot;);</action>
         <tran_glyph conn="114,69,3,-1,28">
          <action box="0,-2,19,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="114,53,30,25">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="Writing">
        <tran trig="I2C_WRITE_DONE" target="../../../../1">
         <action>DBG_printf(&quot;I2C Write finished successfully: wrote %d bytes\n&quot;, ((I2CEvt const *)e)-&gt;wDataLen);</action>
         <tran_glyph conn="115,168,3,1,-91">
          <action box="-18,-2,15,2"/>
         </tran_glyph>
        </tran>
        <state name="WaitForDMAWriteDone">
         <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cDMATimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_DMA_WRITE_SEC )
);

/* Start the DMA write operation */
I2C_StartDMAWrite(
    me-&gt;iBus,
    s_I2C_Bus[me-&gt;iBus].nBytesExpected
);</entry>
         <exit>QTimeEvt_disarm( &amp;me-&gt;i2cDMATimerEvt );</exit>
         <tran trig="I2C_DMA_TIMEOUT" target="../../../../../1">
          <action>ERR_printf(&quot;Timeout while waiting for DMA read timeout\n&quot;);

/* TODO: DEBUG STUFF - remove */
ERR_printf(&quot;DMA1_St6 fifo is at %d\n&quot;, DMA_GetFIFOStatus(DMA1_Stream6) );
ERR_printf(&quot;DMA1_St6 TC flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_IT_TCIF6) );
ERR_printf(&quot;DMA1_St6 FE flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_FEIF6) );
ERR_printf(&quot;DMA1_St6 DM flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_DMEIF6) );
ERR_printf(&quot;DMA1_St6 TE flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_TEIF6) );
ERR_printf(&quot;DMA1_St6 HT flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_HTIF6) );

if (DMA_GetCmdStatus(DMA1_Stream6)== ENABLE) {
    ERR_printf(&quot;DMA1_Stream6 still enabled, turning off\n&quot;);
    DMA_Cmd( DMA1_Stream0, DISABLE );
}

/* Disable Acknowledgment */
I2C_AcknowledgeConfig(s_I2C_Bus[me-&gt;iBus].i2c_bus, DISABLE);

I2C_GenerateSTOP(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);

/* Re-Enable Acknowledgment to be ready for another reception */
I2C_AcknowledgeConfig(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);

DBG_printf(&quot;Generating I2C stop\n&quot;);</action>
          <tran_glyph conn="118,162,3,1,-94">
           <action box="-19,-2,16,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="118,152,25,15">
          <entry box="1,2,6,2"/>
          <exit box="1,4,6,2"/>
         </state_glyph>
        </state>
        <state name="WriteI2CByte">
         <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
         <tran trig="I2C_CHECK_EV">
          <action>/* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
          <choice>
           <guard brief="ReadyToWrite?">I2C_CheckEvent(s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_BYTE_TRANSMITTED)</guard>
           <choice target="../../..">
            <guard>else</guard>
            <action>DBG_printf(&quot;Writing 0x%02x byte %d to I2C Device\n&quot;,
    s_I2C_Bus[me-&gt;iBus].pTxBuffer[ s_I2C_Bus[me-&gt;iBus].nTxIndex ],
    s_I2C_Bus[me-&gt;iBus].nTxIndex
);

/* Send the single byte address to the device */
I2C_SendData(
    s_I2C_Bus[me-&gt;iBus].i2c_bus,
    s_I2C_Bus[me-&gt;iBus].pTxBuffer[ s_I2C_Bus[me-&gt;iBus].nTxIndex++ ]
);</action>
            <choice_glyph conn="158,126,5,0,15,-12,-11">
             <action box="1,0,6,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../1">
            <guard brief="No more bytes?">0 == (s_I2C_Bus[me-&gt;iBus].nBytesExpected - s_I2C_Bus[me-&gt;iBus].nTxIndex)</guard>
            <action>I2C_GenerateSTOP(I2C1, ENABLE);                        /* Generate Stop */
DBG_printf(&quot;Done writing I2C data\n&quot;);</action>
            <choice_glyph conn="158,126,4,1,4,-134">
             <action box="-6,4,13,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="158,121,4,-1,5">
            <action box="0,1,13,2"/>
           </choice_glyph>
          </choice>
          <choice>
           <guard brief="else"/>
           <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
           <choice target="../../..">
            <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
            <choice_glyph conn="147,121,4,0,-4">
             <action box="-10,-3,12,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../1">
            <guard brief="else"/>
            <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n&quot;);</action>
            <choice_glyph conn="147,121,5,1,-123">
             <action box="-8,0,7,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="158,121,5,-1,-11">
            <action box="-7,0,6,2"/>
           </choice_glyph>
          </choice>
          <tran_glyph conn="158,117,2,-1,4">
           <action box="0,0,14,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="144,111,18,6">
          <entry box="1,2,6,2"/>
         </state_glyph>
        </state>
        <state_glyph node="115,105,60,65"/>
       </state>
       <state name="WaitFor_I2C_EV5">
        <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
        <tran trig="I2C_CHECK_EV">
         <action>/* Check if EV5 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
         <choice target="../../../0">
          <guard brief="EV5 Happened?">I2C_CheckEvent(s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_MODE_SELECT)</guard>
          <action brief="Send 7bit address">DBG_printf(&quot;Selecting slave I2C Device\n&quot;);

/* Set the direction to transmit the address */
I2C_SetDirection( me-&gt;iBus,  I2C_Direction_Transmitter);

/* Send slave Address for write */
I2C_Send7bitAddress(
    s_I2C_Bus[me-&gt;iBus].i2c_bus,            /* This is always the bus used in this ISR */
    s_I2C_Dev[me-&gt;iDevice].i2c_dev_addr,    /* Look up the current device address for this bus */
    s_I2C_Bus[me-&gt;iBus].bTransDirection     /* Direction of data on this bus */
);

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
          <choice_glyph conn="60,63,5,3,12,-2,2">
           <action box="0,0,14,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="else"/>
          <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
          <choice target="../../..">
           <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
           <choice_glyph conn="49,63,4,2,-4">
            <action box="0,-3,11,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard brief="else"/>
           <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_MODE_SELECT (EV5)\n&quot;);</action>
           <choice_glyph conn="49,63,5,1,-25">
            <action box="-7,0,6,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="60,63,5,-1,-11">
           <action box="-7,0,6,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="60,59,2,-1,4">
          <action box="0,0,14,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="46,53,18,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="WaitFor_I2C_EV8_MSB">
        <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
        <tran trig="I2C_CHECK_EV">
         <action>/* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
         <choice target="../../../5">
          <guard brief="EV8 Happened?">I2C_CheckEvent( s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_BYTE_TRANSMITTING )</guard>
          <action>DBG_printf(&quot;Sending internal LSB addr to the I2C Device\n&quot;);

/* Send the LSB of the address to the I2C device */
I2C_SendData(
    s_I2C_Bus[me-&gt;iBus].i2c_bus,
    (uint8_t)(s_I2C_Dev[me-&gt;iDevice].i2c_mem_addr &amp; 0x00FF)
);

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
          <choice_glyph conn="60,84,4,0,4">
           <action box="0,1,14,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="else"/>
          <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
          <choice target="../../..">
           <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
           <choice_glyph conn="49,84,4,2,-4">
            <action box="-11,-4,12,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard brief="else"/>
           <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_BYTE_TRANSMITTING (EV8)\n&quot;);</action>
           <choice_glyph conn="49,84,5,1,-25">
            <action box="-8,0,7,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="60,84,5,-1,-11">
           <action box="-7,0,6,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="60,80,2,-1,4">
          <action box="0,0,14,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="46,74,18,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="WaitFor_I2C_EV8_LSB">
        <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
        <tran trig="I2C_CHECK_EV">
         <action>/* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
         <choice>
          <guard brief="EV8 Happened?">SET == I2C_GetFlagStatus(s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_FLAG_BTF)</guard>
          <action>/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
          <choice target="../../../../6/3">
           <guard brief="READ?">I2C_OP_READ == me-&gt;i2cCurrOperation</guard>
           <action>DBG_printf(&quot;Sending a second START bit to the I2C Device\n&quot;);

/* Send START condition */
I2C_GenerateSTART(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);</action>
           <choice_glyph conn="92,101,4,0,2,-40,5">
            <action box="-9,2,8,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard>else</guard>
           <action>ERR_printf(&quot;Invalid I2C operation selected: %d\n&quot;, me-&gt;i2cCurrOperation);</action>
           <choice_glyph conn="92,101,5,1,-68">
            <action box="-7,-2,6,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../2/1">
           <guard brief="WRITE?">I2C_OP_WRITE == me-&gt;i2cCurrOperation</guard>
           <choice_glyph conn="92,101,5,0,30,51">
            <action box="5,-2,8,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="61,98,5,-1,31,3">
           <action box="1,0,14,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="else"/>
          <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
          <choice target="../../..">
           <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
           <choice_glyph conn="50,98,4,2,-4">
            <action box="-10,-3,12,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard brief="else"/>
           <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_BYTE_TRANSMITTING (EV8)\n&quot;);</action>
           <choice_glyph conn="50,98,5,1,-26">
            <action box="-8,0,7,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="61,98,5,-1,-11">
           <action box="-7,0,6,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="61,94,2,-1,4">
          <action box="0,0,14,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="47,88,18,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="Reading">
        <tran trig="I2C_READ_DONE" target="../../../../1">
         <action>DBG_printf(&quot;I2C Read finished successfully: read %d bytes\n&quot;, ((I2CDataEvt const *)e)-&gt;wDataLen);</action>
         <tran_glyph conn="44,134,3,1,-20">
          <action box="-18,-2,15,2"/>
         </tran_glyph>
        </tran>
        <state name="WaitFor_I2C_EV6_R">
         <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
         <tran trig="I2C_CHECK_EV">
          <action>/* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
          <choice target="../../../2">
           <guard brief="EV6 Happened?">I2C_CheckEvent( s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED )</guard>
           <action>DBG_printf(&quot;Starting to read the I2C Device data...\n&quot;);

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
           <choice_glyph conn="90,126,4,0,5,-39,22">
            <action box="0,2,14,2"/>
           </choice_glyph>
          </choice>
          <choice>
           <guard brief="else"/>
           <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
           <choice target="../../..">
            <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
            <choice_glyph conn="79,126,4,0,-4">
             <action box="-10,-3,12,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../1">
            <guard brief="else"/>
            <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n&quot;);</action>
            <choice_glyph conn="79,126,5,1,-55">
             <action box="-8,0,7,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="90,126,5,-1,-11">
            <action box="-7,0,6,2"/>
           </choice_glyph>
          </choice>
          <tran_glyph conn="90,122,2,-1,4">
           <action box="0,0,14,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="76,116,18,6">
          <entry box="1,2,6,2"/>
         </state_glyph>
        </state>
        <state name="WaitForDMAReadDone">
         <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cDMATimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_DMA_READ_SEC )
);

/* Reset the number of bytes already read to 0 */
s_I2C_Bus[me-&gt;iBus].nBytesCurrent = 0;

/* Start the DMA read operation */
I2C_StartDMARead(
    me-&gt;iBus,
    s_I2C_Bus[me-&gt;iBus].nBytesExpected
);</entry>
         <exit>QTimeEvt_disarm( &amp;me-&gt;i2cDMATimerEvt );</exit>
         <tran trig="I2C_DMA_TIMEOUT" target="../../../../../1">
          <action>ERR_printf(&quot;Timeout while waiting for DMA read timeout\n&quot;);

/* TODO: DEBUG STUFF - remove */
ERR_printf(&quot;DMA1_St0 fifo is at %d\n&quot;, DMA_GetFIFOStatus(DMA1_Stream0) );
ERR_printf(&quot;DMA1_St0 TC flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_IT_TCIF0) );
ERR_printf(&quot;DMA1_St0 FE flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_FEIF0) );
ERR_printf(&quot;DMA1_St0 DM flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_DMEIF0) );
ERR_printf(&quot;DMA1_St0 TE flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_TEIF0) );
ERR_printf(&quot;DMA1_St0 HT flag: %d\n&quot;, DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_HTIF0) );

if (DMA_GetCmdStatus(DMA1_Stream0)== ENABLE) {
    ERR_printf(&quot;DMA1_Stream0 still enabled, turning off\n&quot;);
    DMA_Cmd( DMA1_Stream0, DISABLE );
}

/* Disable Acknowledgment */
I2C_AcknowledgeConfig(s_I2C_Bus[me-&gt;iBus].i2c_bus, DISABLE);

I2C_GenerateSTOP(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);

/* Re-Enable Acknowledgment to be ready for another reception */
I2C_AcknowledgeConfig(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);

DBG_printf(&quot;Generating I2C stop\n&quot;);</action>
          <tran_glyph conn="46,155,3,1,-22">
           <action box="-20,-2,16,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="46,153,27,15">
          <entry box="1,2,6,2"/>
          <exit box="1,4,6,2"/>
         </state_glyph>
        </state>
        <state name="WaitFor_I2C_EV5_R">
         <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
         <tran trig="I2C_CHECK_EV">
          <action>/* Check if EV5 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
          <choice target="../../../1">
           <guard brief="EV5 Happened?">I2C_CheckEvent(s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_MODE_SELECT)</guard>
           <action>DBG_printf(&quot;Selecting slave I2C Device\n&quot;);

/* Set the direction to receive */
I2C_SetDirection( me-&gt;iBus,  I2C_Direction_Receiver);

/* Send slave Address for read */
I2C_Send7bitAddress(
    s_I2C_Bus[me-&gt;iBus].i2c_bus,           /* This is always the bus used in this ISR */
    s_I2C_Dev[me-&gt;iDevice].i2c_dev_addr,   /* Look up the current device address for this bus */
    s_I2C_Bus[me-&gt;iBus].bTransDirection    /* Direction of data on this bus */
);

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT * 100;</action>
           <choice_glyph conn="60,118,5,3,16">
            <action box="1,0,14,2"/>
           </choice_glyph>
          </choice>
          <choice>
           <guard brief="else"/>
           <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
           <choice target="../../..">
            <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
            <choice_glyph conn="49,118,4,0,-4">
             <action box="-11,-4,12,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../1">
            <guard brief="else"/>
            <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_MODE_SELECT (EV5)\n&quot;);</action>
            <choice_glyph conn="49,118,5,1,-25">
             <action box="-7,0,6,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="60,118,5,-1,-11">
            <action box="-7,0,6,2"/>
           </choice_glyph>
          </choice>
          <tran_glyph conn="60,114,2,-1,4">
           <action box="0,0,14,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="46,108,18,6">
          <entry box="1,2,6,2"/>
         </state_glyph>
        </state>
        <state name="ReadI2CByte">
         <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
         <tran trig="I2C_CHECK_EV">
          <action>/* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
          <choice>
           <guard brief="ReadyToRead?">RESET != I2C_GetFlagStatus( s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_FLAG_RXNE )</guard>
           <action>/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;

s_I2C_Bus[me-&gt;iBus].pRxBuffer[s_I2C_Bus[me-&gt;iBus].nBytesCurrent++] =
    I2C_ReceiveData(s_I2C_Bus[me-&gt;iBus].i2c_bus);

/** me-&gt;nRead++; Increment number of bytes read */</action>
           <choice target="../../..">
            <guard brief="&gt; 1 byte left?">(s_I2C_Bus[me-&gt;iBus].nBytesExpected - s_I2C_Bus[me-&gt;iBus].nBytesCurrent) &gt; 1</guard>
            <choice_glyph conn="80,147,5,3,-26,-12,12">
             <action box="-12,0,10,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../..">
            <guard brief="1 byte left?">1 == (s_I2C_Bus[me-&gt;iBus].nBytesExpected - s_I2C_Bus[me-&gt;iBus].nBytesCurrent)</guard>
            <action>DBG_printf(&quot;Done Reading\n&quot;);
I2C_AcknowledgeConfig( I2C1, DISABLE);        /* Disable Acknowledgment */
I2C_GenerateSTOP(I2C1, ENABLE);                        /* Generate Stop */</action>
            <choice_glyph conn="80,147,5,1,15,-12,-11">
             <action box="1,0,13,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../1">
            <guard>else</guard>
            <action>I2C_AcknowledgeConfig(I2C1, ENABLE);        /* Re-enable Acknowledgment */
DBG_printf(&quot;Done reading I2C data\n&quot;);</action>
            <choice_glyph conn="80,147,4,1,4,-56">
             <action box="-6,4,6,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="80,142,4,-1,5">
            <action box="0,1,13,2"/>
           </choice_glyph>
          </choice>
          <choice>
           <guard brief="else"/>
           <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
           <choice target="../../..">
            <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
            <choice_glyph conn="69,142,4,0,-4">
             <action box="-10,-3,12,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../1">
            <guard brief="else"/>
            <action>ERR_printf(&quot;Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n&quot;);</action>
            <choice_glyph conn="69,142,5,1,-45">
             <action box="-8,0,7,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="80,142,5,-1,-11">
            <action box="-7,0,6,2"/>
           </choice_glyph>
          </choice>
          <tran_glyph conn="80,138,2,-1,4">
           <action box="0,0,14,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="66,132,18,6">
          <entry box="1,2,6,2"/>
         </state_glyph>
        </state>
        <state_glyph node="44,105,60,65"/>
       </state>
       <state_glyph node="42,49,141,123">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitFor_I2C_EV5_REC">
       <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
       <tran trig="I2C_CHECK_EV">
        <action>/* Check if EV5 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
        <choice target="../../../5">
         <guard brief="EV5 Happened?">I2C_CheckEvent(s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_MODE_SELECT)</guard>
         <action brief="Send 7bit address">WRN_printf(&quot;Selecting slave I2C Device\n&quot;);

/* Set the direction to transmit the address */
I2C_SetDirection( me-&gt;iBus,  I2C_Direction_Transmitter);

/* Send slave Address for write */
I2C_Send7bitAddress(
    s_I2C_Bus[me-&gt;iBus].i2c_bus,            /* This is always the bus used in this ISR */
    s_I2C_Dev[me-&gt;iDevice].i2c_dev_addr,    /* Look up the current device address for this bus */
    s_I2C_Bus[me-&gt;iBus].bTransDirection     /* Direction of data on this bus */
);

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
         <choice_glyph conn="127,26,4,0,4">
          <action box="0,1,14,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="else"/>
         <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
         <choice target="../../..">
          <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
          <choice_glyph conn="116,26,4,0,-4">
           <action box="0,-3,11,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../6">
          <guard brief="else"/>
          <action>WRN_printf(&quot;Expected timeout waiting for EV5 after bus recovery\n&quot;);</action>
          <choice_glyph conn="116,26,5,1,-6,-8,-48">
           <action box="-7,0,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="127,26,5,-1,-11">
          <action box="-7,0,6,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="127,22,2,-1,4">
         <action box="0,0,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="113,16,18,6">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitFor_I2C_EV6_REC">
       <entry>/* Post an event to check for EV5 event */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
       <tran trig="I2C_CHECK_EV">
        <action>/* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
        <choice target="../../../6">
         <guard brief="EV6 Happened?">I2C_CheckEvent( s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED )</guard>
         <choice_glyph conn="127,40,4,1,2,-19,-22,-46">
          <action box="0,1,14,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="else"/>
         <action>me-&gt;nI2CLoopTimeout--;                 /* Decrement counter */</action>
         <choice target="../../..">
          <guard brief="Retries left?">me-&gt;nI2CLoopTimeout != 0</guard>
          <choice_glyph conn="116,40,4,0,-4">
           <action box="0,-3,11,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../6">
          <guard brief="else"/>
          <action>WRN_printf(&quot;Expected timeout waiting for I2C EV6 after bus recovery\n&quot;);</action>
          <choice_glyph conn="116,40,5,1,-7,-21,-47">
           <action box="-8,0,7,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="127,40,5,-1,-11">
          <action box="-7,0,6,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="127,36,2,-1,4">
         <action box="0,0,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="113,30,18,6">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="StartI2CComm">
       <entry>/* Create event to check event and publish it */
QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);</entry>
       <tran trig="I2C_CHECK_EV">
        <action>/* Check if bus is busy.  If free, go on to the next state.  Otherwise,
 * try again until number of retries is out */</action>
        <choice target="../../../3/3">
         <guard brief="Bus Free?">RESET == I2C_GetFlagStatus( s_I2C_Bus[me-&gt;iBus].i2c_bus, I2C_FLAG_BUSY )</guard>
         <action>DBG_printf(&quot;Bus free and ready\n&quot;);

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
         <choice_glyph conn="48,39,4,0,14">
          <action box="-8,1,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../2/0">
         <guard>else</guard>
         <choice_glyph conn="48,39,5,3,26">
          <action box="2,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="48,29,2,-1,10">
         <action box="0,1,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="43,16,19,13">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitForBusToSettle">
       <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cRecoveryTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUS_RECOVERY_SEC )
);

/* Rearm the main I2C timer for a value that is enough for the current recovery
 * effort and enough to retry the operation that caused the problem in the first
 * place */
QTimeEvt_rearm(
    &amp;me-&gt;i2cTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUSY_SEC + LL_MAX_TIMEOUT_I2C_BUS_RECOVERY_SEC )
);
</entry>
       <exit>QTimeEvt_disarm( &amp;me-&gt;i2cRecoveryTimerEvt );</exit>
       <tran trig="I2C_RECOVERY_TIMEOUT" target="../../4">
        <action>WRN_printf(&quot;Finished waiting for bus to settle after reset and intentional failure\n&quot;);

/* Send START condition */
WRN_printf(&quot;Generating I2C start after bus reset\n&quot;);
I2C_GenerateSTART(s_I2C_Bus[me-&gt;iBus].i2c_bus, ENABLE);</action>
        <tran_glyph conn="144,27,0,1,-8,-13">
         <action box="0,-3,22,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="142,27,17,8">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="40,10,145,169">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="Idle">
      <documentation>/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* recall the request from the private requestQueue */
QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);

/*
I2CEvt const *rq = (I2CEvt const *) (uint32_t) QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);
rq = 0; // To prevent compiler warning about unused var.
*/

/* Clear out current operation */
me-&gt;i2cCurrOperation = I2C_OP_NONE;

DBG_printf(&quot;back in Idle\n&quot;);</entry>
      <tran trig="I2C_READ_START" target="../../0/6">
       <action>DBG_printf(&quot;Got I2C_READ_START\n&quot;);

/* Set the current I2C operation */
me-&gt;i2cCurrOperation = I2C_OP_READ;

/* Store the device */
me-&gt;iDevice = ((I2CEvt const *)e)-&gt;i2cDevice;

/* Store device and operation settings from the event */
s_I2C_Dev[me-&gt;iDevice].i2c_mem_addr = ((I2CEvt const *)e)-&gt;wAddr;
s_I2C_Bus[me-&gt;iBus].nBytesExpected = ((I2CEvt const *)e)-&gt;wDataLen;
s_I2C_Bus[me-&gt;iBus].nBytesCurrent = 0;
s_I2C_Bus[me-&gt;iBus].nRxIndex = 0;

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
       <tran_glyph conn="24,18,1,3,19">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C_WRITE_START" target="../../0/6">
       <action>DBG_printf(&quot;Got I2C_WRITE_START\n&quot;);

/* Set the current I2C operation */
me-&gt;i2cCurrOperation = I2C_OP_WRITE;

/* Store the device */
me-&gt;iDevice = ((I2CDataEvt const *)e)-&gt;i2cDevice;

/* Store device and operation settings from the event */
s_I2C_Dev[me-&gt;iDevice].i2c_mem_addr = ((I2CDataEvt const *)e)-&gt;wAddr;
s_I2C_Bus[me-&gt;iBus].nBytesExpected = ((I2CDataEvt const *)e)-&gt;wDataLen;
s_I2C_Bus[me-&gt;iBus].nBytesCurrent = 0;
s_I2C_Bus[me-&gt;iBus].nTxIndex = 0;

/* Copy data from the event to the buffer */
MEMCPY(
    s_I2C_Bus[me-&gt;iBus].pTxBuffer,
    ((I2CDataEvt const *)e)-&gt;bufData,
    ((I2CDataEvt const *)e)-&gt;wDataLen
);

/* Reset the maximum number of times to poll the I2C bus for an event */
me-&gt;nI2CLoopTimeout = MAX_I2C_TIMEOUT;</action>
       <tran_glyph conn="24,21,1,3,19">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="5,10,19,169">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,6,184,174">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="189,181"/>
   </statechart>
  </class>
  <attribute name="AO_I2CMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="I2CMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for I2CMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param  [in] i2cBus: I2C_TypeDef * type that specifies which STM32 I2C bus this
 * AO is responsible for.
 * @retval None
 */</documentation>
   <parameter name="iBus" type="I2C_Bus_t"/>
   <code>I2CMgr *me = &amp;l_I2CMgr;
me-&gt;iBus = iBus;

QActive_ctor( &amp;me-&gt;super, (QStateHandler)&amp;I2CMgr_initial );
QTimeEvt_ctor( &amp;me-&gt;i2cTimerEvt, I2C_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cDMATimerEvt, I2C_DMA_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cRecoveryTimerEvt, I2C_RECOVERY_TIMEOUT_SIG );

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);

dbg_slow_printf(&quot;Constructor\n&quot;);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="I2CMgr_gen.c">
   <text>/**
 * @file    I2CMgr.c
 * @brief   Declarations for functions for the I2CMgr AO.
 * This state machine handles all I/O on the I2C bus.
 *
 * @note 1: If editing this file, please make sure to update the I2CMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    07/01/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;I2CMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp.h&quot;          /* For seconds to bsp tick conversion (SEC_TO_TICK) */

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_I2C ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::I2CMgr)

/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static I2CMgr l_I2CMgr;           /* the single instance of the active object */

/* Global-scope objects ----------))------------------------------------------*/
QActive * const AO_I2CMgr = (QActive *)&amp;l_I2CMgr;      /* &quot;opaque&quot; AO pointer */
extern I2C_BusSettings_t s_I2C_Bus[MAX_I2C_BUS];
extern I2C_BusDevice_t   s_I2C_Dev[MAX_I2C_DEV];

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::I2CMgr_ctor)
$define(AOs::I2CMgr)

/**
 * @} end addtogroup groupI2C
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="I2CMgr_gen.h">
   <text>/**
 * @file    I2CMgr.h
 * @brief   Declarations for functions for the I2CMgr AO.
 * This state machine handles all I/O on the I2C bus.
 *
 * @note 1: If editing this file, please make sure to update the I2CMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    07/01/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef I2CMGR_H_
#define I2CMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;                                   /*  Common Declarations */
#include &quot;i2c.h&quot;                               /* For I2C device declarations */

/* Exported defines ----------------------------------------------------------*/
#define MAX_BUS_RETRIES   100 /**&lt; Max number of retries for I2C bus for busy flag */
#define MAX_I2C_TIMEOUT 10000 /**&lt; Max number of retries for I2C bus for busy flag */
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::I2CMgr_ctor)
$declare(AOs::AO_I2CMgr)

/**
 * @} end addtogroup groupI2C
 */
#endif                                                           /* I2CMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
