<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="I2CEEPROMReadReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a raw memory read request.
 */</documentation>
   <attribute name="addr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Internal memory address of the I2C device*/</documentation>
   </attribute>
   <attribute name="bytes" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specify how many bytes to read */</documentation>
   </attribute>
  </class>
  <class name="I2CEEPROMWriteReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a memory write request.
 */</documentation>
   <attribute name="addr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Internal memory address of the I2C device*/</documentation>
   </attribute>
   <attribute name="bytes" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specify how many bytes to read */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_I2C_READ_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data. */</documentation>
   </attribute>
  </class>
  <class name="I2CDevRegWriteReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a register write request.
 */</documentation>
   <attribute name="regAddr" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Internal register address of the I2C device*/</documentation>
   </attribute>
   <attribute name="regValue" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Value to write to register. */</documentation>
   </attribute>
  </class>
  <class name="I2CDevRegReadReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a register read request.
 */</documentation>
   <attribute name="regAddr" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Internal register address of the I2C device*/</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="I2C1DevMgr" superclass="qpc::QActive">
   <documentation>/**
 * @brief I2C1DevMgr Active Object (AO) &quot;class&quot; that manages the all the I2C
 * devices on the I2C1 Bus.
 * This AO manages the devices connected to the I2C1 bus and all events a
 * ssociated with those devices. It deesn't access to the I2C1 bus directly and
 * instead communicates with the I2CBusMgr AO to request and monitor the direct
 * I2C commands that need to be sent down that are specific for the device that
 * is currently being handled.  See I2CDevMgr.qm for diagram and model.
 */</documentation>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="iDev" type="I2CBus1_Dev_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies which I2CBus1 device is currently being handled by this AO.
 * This should be set when a new I2C_READ_START or I2C_WRITE_START events come
 * in.  Those events should contain the device for which they are meant for. */</documentation>
   </attribute>
   <attribute name="iBus" type="I2C_Bus_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C bus this AO is responsible for.  This variable is set on
     startup and is used to index into the structure that holds all the
     I2C bus settings. */</documentation>
   </attribute>
   <attribute name="i2cTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout overall I2C device interactions. */</documentation>
   </attribute>
   <attribute name="i2cOpTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout discrete I2C bus requests to the I2C1DevMgr AO. */</documentation>
   </attribute>
   <attribute name="bytesTotal" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Total number of bytes to be read or written with an operation */</documentation>
   </attribute>
   <attribute name="bytesCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Number of bytes already read or written as part of the bytesTotal.
 * This is for R/W operations that don't fit into a single bus request */</documentation>
   </attribute>
   <attribute name="addrStart" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the starting internal memory address of a read or a
 write operation */</documentation>
   </attribute>
   <attribute name="addrSize" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Number of bytes the &quot;address&quot; variables are */</documentation>
   </attribute>
   <attribute name="addrCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the last memory location accessed.  This is for R/W operations
 * that don't fit into a single bus request */</documentation>
   </attribute>
   <attribute name="errorCode" type="CBErrorCode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of last error that occurs. */</documentation>
   </attribute>
   <attribute name="i2cDevOp" type="I2C_Operation_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of whether a read, write or other was requested */</documentation>
   </attribute>
   <attribute name="i2cWriteTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to time post EEPROM writes. */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_I2C_READ_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data for reads and writes.  It's set to a larger of the
 * I2C sizes since reads can be large while the writes have to be broken into 
 * page sized chunks. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/1">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

me-&gt;iBus = I2CBus1;          /* This AO only handles devices on I2CBus1 */

QS_OBJ_DICTIONARY(&amp;l_I2C1DevMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;I2C1DevMgr_initial);
QS_FUN_DICTIONARY(&amp;I2C1DevMgr_Active);
QS_FUN_DICTIONARY(&amp;I2C1DevMgr_Idle);

QActive_subscribe((QActive *)me, EEPROM_SN_READ_SIG);
QActive_subscribe((QActive *)me, EEPROM_EUI64_READ_SIG);
QActive_subscribe((QActive *)me, EEPROM_RAW_MEM_WRITE_SIG);
QActive_subscribe((QActive *)me, EEPROM_RAW_MEM_READ_SIG);
QActive_subscribe((QActive *)me, IOEXP_REG_READ_SIG);
QActive_subscribe((QActive *)me, IOEXP_REG_WRITE_SIG);
QActive_subscribe((QActive *)me, TSC_POS_READ_SIG);</action>
     <initial_glyph conn="1,2,4,3,9,5">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and 
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Post and disarm all the timer events so they can be rearmed at any time */
QTimeEvt_postIn(
    &amp;me-&gt;i2cTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);
QTimeEvt_disarm(&amp;me-&gt;i2cTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cOpTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);
QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cWriteTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);
QTimeEvt_disarm(&amp;me-&gt;i2cWriteTimerEvt);</entry>
     <state name="Busy">
      <documentation>/**
 * @brief   This state indicates that the I2C is currently busy and cannot
 * process incoming data; incoming events will be deferred in this state and
 * handled once the AO goes back to Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_DEV_REQ )
);</entry>
      <exit>QTimeEvt_disarm( &amp;me-&gt;i2cTimerEvt ); /* Disarm timer on exit */</exit>
      <tran trig="I2C1_DEV_TIMEOUT" target="../../1">
       <action>ERR_printf(&quot;I2C1Dev timeout occurred with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
       <tran_glyph conn="46,11,3,1,-19">
        <action box="-17,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="EEPROM_RAW_MEM_READ, EEPROM_SN_READ, EEPROM_EUI64_READ, EEPROM_RAW_MEM_WRITE, IOEXP_REG_READ, IOEXP_REG_WRITE, TSC_POS_READ">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
   DBG_printf(&quot;Deferring I2C request until current is done\n&quot;);
} else {
   /* notify the request sender that the request was ignored.. */
   ERR_printf(&quot;Unable to defer I2C request\n&quot;);
}</action>
       <tran_glyph conn="46,224,3,-1,21">
        <action box="0,-14,21,13"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C1_DEV_OP_TIMEOUT" target="../../1">
       <action>ERR_printf(&quot;I2C1Dev Op timeout occurred with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
       <tran_glyph conn="46,13,3,1,-19">
        <action box="-20,-2,21,2"/>
       </tran_glyph>
      </tran>
      <state name="GenerateStart">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_START_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="85,22,4,1,5,-58">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../4">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="85,22,5,3,5,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="71,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="71,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrTxMode">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1DevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="107,22,4,1,6,-80">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../5">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="107,22,5,3,5,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="93,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="93,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendInternalAddr">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = me-&gt;addrStart;
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="129,22,4,1,7,-102">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice target="../../../../6">
          <guard brief="Read?">I2C_OP_MEM_READ == me-&gt;i2cDevOp || I2C_OP_REG_READ == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="137,22,4,0,10,-86,2">
           <action box="-6,10,7,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../9">
          <guard brief="Write?">I2C_OP_MEM_WRITE == me-&gt;i2cDevOp || I2C_OP_REG_WRITE == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="137,22,4,3,-7,7">
           <action box="0,-9,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="129,22,5,-1,8">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="115,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="115,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStart1">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,44,4,1,5,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../7">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="63,44,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,44,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,34,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrRxMode">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1DevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Receiver;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="87,44,4,1,6,-60">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../8">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="87,44,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="73,44,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="73,34,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="ReadMem">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_READ_MEM_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_READ )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CReadMemReqEvt *i2cReadMemEvt = Q_NEW( I2CReadMemReqEvt, I2C_BUS_READ_MEM_SIG );
i2cReadMemEvt-&gt;i2cBus           = me-&gt;iBus;
i2cReadMemEvt-&gt;addr             = me-&gt;addrStart;
i2cReadMemEvt-&gt;addrSize         = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cReadMemEvt-&gt;memAccessType    = I2C_MEM_DMA;
i2cReadMemEvt-&gt;bytes            = me-&gt;bytesTotal; //TODO: remember to fix this.  This should not exceed max page size.
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cReadMemEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="111,44,4,1,7,-84">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="NoErr?">ERR_NONE == ((I2CBusDataEvt const *)e)-&gt;errorCode</guard>
         <action>LOG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);
char tmp[120];
memset(tmp, 0, sizeof(tmp));
uint16_t tmpLen = 0;
CBErrorCode err = CON_hexToStr(
    (const uint8_t *)((I2CBusDataEvt const *)e)-&gt;dataBuf, // data to convert
    ((I2CBusDataEvt const *)e)-&gt;dataLen, // length of data to convert
    tmp,                                 // where to write output
    sizeof(tmp),                         // max size of output buffer
    &amp;tmpLen,                             // size of the resulting output
    0,                                   // no columns
    ' '                                  // separator
);
if ( ERR_NONE != err ) {
    WRN_printf(&quot;Got an error converting hex array to string.  Error: 0x%08x\n&quot;, err);
}
LOG_printf(&quot;Read %s\n&quot;, tmp);</action>
         <choice_glyph conn="111,44,5,1,9,10,-93">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="97,44,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="97,34,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WriteMem">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_WRITE_MEM_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_WRITE )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CWriteMemReqEvt *i2cWriteMemReqEvt = Q_NEW( I2CWriteMemReqEvt, I2C_BUS_WRITE_MEM_SIG );
i2cWriteMemReqEvt-&gt;i2cBus           = me-&gt;iBus;
i2cWriteMemReqEvt-&gt;addr             = me-&gt;addrStart;
i2cWriteMemReqEvt-&gt;addrSize         = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cWriteMemReqEvt-&gt;memAccessType    = I2C_MEM_DMA;
i2cWriteMemReqEvt-&gt;bytes            = me-&gt;bytesTotal; //TODO: remember to fix this.  This should not exceed max page size.
MEMCPY(
    i2cWriteMemReqEvt-&gt;dataBuf,
    me-&gt;dataBuf,
    i2cWriteMemReqEvt-&gt;bytes
);
DBG_printf(&quot;QACTPosting I2C_BUS_WRITE_MEM_SIG with %d bytes\n&quot;, i2cWriteMemReqEvt-&gt;bytes );
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cWriteMemReqEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="158,22,4,1,8,-17,25,-114">
          <action box="-6,6,7,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../10">
         <guard brief="NoErr?">ERR_NONE == ((I2CBusDataEvt const *)e)-&gt;errorCode</guard>
         <action>LOG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);
char tmp[120];
memset(tmp, 0, sizeof(tmp));
uint16_t tmpLen = 0;
CBErrorCode err = CON_hexToStr(
    (const uint8_t *)((I2CBusDataEvt const *)e)-&gt;dataBuf, // data to convert
    ((I2CBusDataEvt const *)e)-&gt;dataLen, // length of data to convert
    tmp,                                 // where to write output
    sizeof(tmp),                         // max size of output buffer
    &amp;tmpLen,                             // size of the resulting output
    0,                                   // no columns
    ' '                                  // separator
);
if ( ERR_NONE != err ) {
    WRN_printf(&quot;Got an error converting hex array to string.  Error: 0x%08x\n&quot;, err);
}
LOG_printf(&quot;Read %s\n&quot;, tmp);</action>
         <choice_glyph conn="158,22,5,1,13,19,-2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="144,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="144,12,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="PostWriteWait">
       <entry>/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    MS_TO_TICKS( HL_MAX_TIME_MS_I2C_POST_WRITE )
);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cWriteTimerEvt);</exit>
       <tran trig="EEPROM_POST_WRITE_TIMER" target="../../../1">
        <action>DBG_printf(&quot;Write to EEPROM finished with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
        <tran_glyph conn="145,47,3,1,26,9,-144">
         <action box="0,-2,24,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="145,37,24,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="CheckingBus">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_CHECK_BUS_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_BUS_CHECK )
);

/* Allocate a dynamic event to send back the result after attempting to recover
 * the I2C bus. */
I2CAddrEvt *i2cAddrEvt = Q_NEW( I2CAddrEvt, I2C_BUS_CHECK_FREE_SIG );
i2cAddrEvt-&gt;i2cBus     = me-&gt;iBus;
i2cAddrEvt-&gt;addr       = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize   = I2C_getI2C1DevAddrSize(me-&gt;iDev);
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)(i2cAddrEvt), me);

DBG_printf(&quot;ActivePosted I2C_BUS_CHECK_FREE\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,22,4,1,4,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../3">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="63,22,5,3,5,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="CheckingBusIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_CHECK_BUS_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_BUS_CHECK )
);

/* Allocate a dynamic event to send back the result after attempting to recover
 * the I2C bus. */
I2CAddrEvt *i2cAddrEvt = Q_NEW( I2CAddrEvt, I2C_BUS_CHECK_FREE_SIG );
i2cAddrEvt-&gt;i2cBus     = me-&gt;iBus;
i2cAddrEvt-&gt;addr       = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize   = I2C_getI2C1DevAddrSize(me-&gt;iDev);
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)(i2cAddrEvt), me);

DBG_printf(&quot;ActivePosted I2C_BUS_CHECK_FREE\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,73,4,1,4,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../13">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="63,73,5,3,6,2,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,73,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,64,16,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStartIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_START_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="85,73,4,1,5,-58">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice target="../../../../15">
          <guard brief="Write?">I2C_OP_MEM_WRITE == me-&gt;i2cDevOp || I2C_OP_REG_WRITE == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="92,73,4,3,-10,25,5,1">
           <action box="0,-12,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../14">
          <guard brief="Read?">I2C_OP_MEM_READ == me-&gt;i2cDevOp || I2C_OP_REG_READ == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="92,73,4,3,2,4">
           <action box="0,2,7,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="85,73,5,-1,7">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="71,73,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="71,64,16,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="DisableAckIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_ACK_DIS_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_ACK_DIS_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_ACK_DIS\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="110,73,4,1,6,-83">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../15">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="110,73,5,3,6,2,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="96,73,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="96,64,16,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrTxModeIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1DevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="132,73,4,1,7,-105">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../16">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="132,73,5,3,10,2,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="118,73,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="118,64,20,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendInternalAddrIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = me-&gt;addrStart;
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="159,74,4,1,7,-132">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice target="../../../../17">
          <guard brief="Read?">I2C_OP_MEM_READ == me-&gt;i2cDevOp || I2C_OP_REG_READ == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="168,84,5,0,-115,2">
           <action box="1,-2,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../22">
          <guard brief="Write?">I2C_OP_MEM_WRITE == me-&gt;i2cDevOp || I2C_OP_REG_WRITE == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="168,84,4,0,24,-115,2">
           <action box="0,2,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="159,74,5,-1,9,10">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="145,74,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="145,64,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStartIOE1">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_START_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,96,4,1,4,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../18">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="63,96,5,3,6,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,96,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,86,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrRxModeIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1DevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Receiver;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="85,96,4,1,5,-58">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../19">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="85,96,5,3,10,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="71,96,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="71,86,20,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStopRIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_STOP_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_STOP_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="111,96,4,1,6,-84">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../20">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="111,96,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="97,96,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="97,86,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="ReadRegIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_READ_MEM_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_READ )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CReadMemReqEvt *i2cReadMemEvt = Q_NEW( I2CReadMemReqEvt, I2C_BUS_READ_MEM_SIG );
i2cReadMemEvt-&gt;i2cBus           = me-&gt;iBus;
i2cReadMemEvt-&gt;addr             = me-&gt;addrStart;
i2cReadMemEvt-&gt;addrSize         = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cReadMemEvt-&gt;memAccessType    = I2C_MEM_BYTE;
i2cReadMemEvt-&gt;bytes            = me-&gt;bytesTotal;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cReadMemEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="135,96,4,1,7,-108">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../21">
         <guard brief="NoErr?">ERR_NONE == ((I2CBusDataEvt const *)e)-&gt;errorCode</guard>
         <action>LOG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);
char tmp[10];
memset(tmp, 0, sizeof(tmp));
uint16_t tmpLen = 0;
CBErrorCode err = CON_hexToStr(
    (const uint8_t *)((I2CBusDataEvt const *)e)-&gt;dataBuf, // data to convert
    ((I2CBusDataEvt const *)e)-&gt;dataLen, // length of data to convert
    tmp,                                 // where to write output
    sizeof(tmp),                         // max size of output buffer
    &amp;tmpLen,                             // size of the resulting output
    0,                                   // no columns
    ' '                                  // separator
);
if ( ERR_NONE != err ) {
    WRN_printf(&quot;Got an error converting hex array to string.  Error: 0x%08x\n&quot;, err);
}
LOG_printf(&quot;Read %s\n&quot;, tmp);</action>
         <choice_glyph conn="135,96,5,3,6,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="121,96,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="121,86,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="EnableAckIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_ACK_EN_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_ACK_EN_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_ACK_EN\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="157,96,4,1,8,-130">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>LOG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="157,96,5,1,9,10,-139">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="143,96,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="143,86,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendRegValueIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = me-&gt;dataBuf[0];
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,120,4,1,3,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../23">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="63,120,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,120,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,110,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStopWIOE">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_STOP_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_STOP_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="87,120,4,1,4,-60">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);
LOG_printf(
    &quot;Wrote 0x%02x to address 0x%02x on I2CBus%d device %d\n&quot;, 
    me-&gt;dataBuf[0],
    me-&gt;addrStart,
    me-&gt;iBus+1,
    me-&gt;iDev
);</action>
         <choice_glyph conn="87,120,5,1,8,7,-68">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="73,120,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="73,110,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStartTSC">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_START_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,141,4,1,3,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../25">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="63,141,5,3,6,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,141,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,131,17,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrTxModeTSC">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1DevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="86,140,4,1,5,-59">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../26">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="86,140,5,3,10,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="72,140,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="72,131,20,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendInternalAddrTSC">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1MemAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="112,141,4,1,5,-85">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../27">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="112,141,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="98,141,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="98,131,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendInternalAddrTSC1">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1MinMemAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="136,141,4,1,6,-109">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../28">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="136,141,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="122,141,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="122,131,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendInternalAddrTSC2">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1PageSize(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="160,141,4,1,7,-133">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../29">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="160,141,5,0,8,9,-117,2">
          <action box="1,-2,8,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="146,141,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="146,131,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStopTSC">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_STOP_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_STOP_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,162,4,1,3,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../30">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);
LOG_printf(
    &quot;Wrote 0x%02x to address 0x%02x on I2CBus%d device %d\n&quot;, 
    me-&gt;dataBuf[0],
    me-&gt;addrStart,
    me-&gt;iBus+1,
    me-&gt;iDev
);</action>
         <choice_glyph conn="63,162,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,162,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,152,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStartTSC1">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_START_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="87,162,4,1,4,-60">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../31">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="87,162,5,3,6,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="73,162,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="73,152,17,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrTxModeTSC1">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1DevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="110,162,4,1,5,-83">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../32">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="110,162,5,3,10,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="96,162,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="96,152,20,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendInternalAddrTSC3">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1MaxMemAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Receiver;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="136,162,4,1,6,-109">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../33">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="136,162,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="122,162,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="122,152,18,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStartTSC2">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_START_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="160,162,4,1,7,-133">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../34">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="160,162,5,0,8,9,-116,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="146,162,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="146,152,17,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrRxModeTSC">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getI2C1DevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getI2C1DevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Receiver;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="63,184,4,1,4,-36">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../35">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);</action>
         <choice_glyph conn="63,184,5,3,9,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="49,184,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="49,174,19,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="ReadMemDMATSC">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_READ_MEM_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_READ )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CReadMemReqEvt *i2cReadMemEvt = Q_NEW( I2CReadMemReqEvt, I2C_BUS_READ_MEM_SIG );
i2cReadMemEvt-&gt;i2cBus           = me-&gt;iBus;
i2cReadMemEvt-&gt;addr             = me-&gt;addrStart;
i2cReadMemEvt-&gt;addrSize         = I2C_getI2C1MemAddrSize(me-&gt;iDev);
i2cReadMemEvt-&gt;memAccessType    = I2C_MEM_DMA;
i2cReadMemEvt-&gt;bytes            = 11; // This is how many bytes we'll read over DMA
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cReadMemEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
ERR_printf(
    &quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;,
    me-&gt;errorCode
);</action>
         <choice_glyph conn="88,184,4,1,5,-61">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="NoErr?">ERR_NONE == ((I2CBusDataEvt const *)e)-&gt;errorCode</guard>
         <action>LOG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);
char tmp[120];
memset(tmp, 0, sizeof(tmp));
uint16_t tmpLen = 0;
CBErrorCode err = CON_hexToStr(
    (const uint8_t *)((I2CBusDataEvt const *)e)-&gt;dataBuf, // data to convert
    ((I2CBusDataEvt const *)e)-&gt;dataLen, // length of data to convert
    tmp,                                 // where to write output
    sizeof(tmp),                         // max size of output buffer
    &amp;tmpLen,                             // size of the resulting output
    0,                                   // no columns
    ' '                                  // separator
);
if ( ERR_NONE != err ) {
    WRN_printf(&quot;Got an error converting hex array to string.  Error: 0x%08x\n&quot;, err);
}
LOG_printf(&quot;Read %s\n&quot;, tmp);</action>
         <choice_glyph conn="88,184,5,1,8,10,-69">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="74,184,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="74,174,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="46,7,132,220">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="Idle">
      <documentation>/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 * This state is the default rest state of the state machine and can handle
 * various I2C requests.  Upon entry, it also checks the deferred queue to see
 * if any request events are waiting which were posted while I2C bus was busy.
 * if there are any waiting, it will read them out, which automatically posts
 * them and the state machine will go and handle them.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* recall the request from the private requestQueue */
QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);

DBG_printf(&quot;back in Idle\n&quot;);</entry>
      <exit>me-&gt;bytesCurr = 0; // Reset the current byte counter</exit>
      <tran trig="EEPROM_RAW_MEM_READ" target="../../0/11">
       <action>me-&gt;iDev = EEPROM; // Set which device is being accessed
me-&gt;addrStart = ((I2CEEPROMReadReqEvt const *)e)-&gt;addr;
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = ((I2CEEPROMReadReqEvt const *)e)-&gt;bytes;
me-&gt;i2cDevOp = I2C_OP_MEM_READ;</action>
       <tran_glyph conn="6,15,3,3,43">
        <action box="0,-2,23,2"/>
       </tran_glyph>
      </tran>
      <tran trig="EEPROM_SN_READ" target="../../0/11">
       <action>me-&gt;iDev = SN_ROM; // Set which device is being accessed
me-&gt;addrStart = I2C_getI2C1MinMemAddr(me-&gt;iDev);
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = I2C_getI2C1PageSize(me-&gt;iDev);
me-&gt;i2cDevOp = I2C_OP_MEM_READ;</action>
       <tran_glyph conn="6,17,3,3,43">
        <action box="0,-2,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="EEPROM_EUI64_READ" target="../../0/11">
       <action>me-&gt;iDev = EUI_ROM; // Set which device is being accessed
me-&gt;addrStart = I2C_getI2C1MinMemAddr(me-&gt;iDev);
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = I2C_getI2C1PageSize(me-&gt;iDev);
me-&gt;i2cDevOp = I2C_OP_MEM_READ;</action>
       <tran_glyph conn="6,19,3,3,43">
        <action box="0,-2,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="EEPROM_RAW_MEM_WRITE" target="../../0/11">
       <action>me-&gt;iDev = EEPROM; // Set which device is being accessed
me-&gt;addrStart = ((I2CEEPROMWriteReqEvt const *)e)-&gt;addr;
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = ((I2CEEPROMWriteReqEvt const *)e)-&gt;bytes;
me-&gt;i2cDevOp = I2C_OP_MEM_WRITE;
MEMCPY(
    me-&gt;dataBuf,
    ((I2CEEPROMWriteReqEvt const *)e)-&gt;dataBuf,
    me-&gt;bytesTotal
);</action>
       <tran_glyph conn="6,21,3,3,43">
        <action box="0,-2,22,2"/>
       </tran_glyph>
      </tran>
      <tran trig="IOEXP_REG_READ" target="../../0/12">
       <action>me-&gt;iDev = IO_EXP; // Set which device is being accessed
me-&gt;addrStart = ((I2CDevRegReadReqEvt const *)e)-&gt;regAddr;
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = 1;
me-&gt;i2cDevOp = I2C_OP_REG_READ;

/*
// Testing IO Expander manually
DBG_printf(&quot;Testing IOExpander (blocking): init\n&quot;);
uint8_t status = IOE16_Config();
DBG_printf(&quot;Init returned status %d\n&quot;, status);
*/</action>
       <tran_glyph conn="6,68,3,3,43">
        <action box="0,-2,23,2"/>
       </tran_glyph>
      </tran>
      <tran trig="IOEXP_REG_WRITE" target="../../0/12">
       <action>me-&gt;iDev = IO_EXP; // Set which device is being accessed
me-&gt;addrStart = ((I2CDevRegWriteReqEvt const *)e)-&gt;regAddr;
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = 1;
me-&gt;dataBuf[0] = ((I2CDevRegWriteReqEvt const *)e)-&gt;regValue;
me-&gt;i2cDevOp = I2C_OP_REG_WRITE;</action>
       <tran_glyph conn="6,70,3,3,43">
        <action box="0,-2,23,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TSC_POS_READ" target="../../0/24">
       <action>me-&gt;iDev = TS_CNTRL; // Set which device is being accessed
me-&gt;addrStart = I2C_getI2C1MinMemAddr(me-&gt;iDev);
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = I2C_getI2C1PageSize(me-&gt;iDev);
me-&gt;i2cDevOp = I2C_OP_MEM_READ;

/*
// Testing IO Expander manually
DBG_printf(&quot;Testing IOExpander (blocking): init\n&quot;);
uint8_t status = IOE16_Config();
DBG_printf(&quot;Init returned status %d\n&quot;, status);
*/</action>
       <tran_glyph conn="6,136,3,3,43">
        <action box="0,-2,23,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TSC_CLR_INT" target="../../0/12">
       <action>me-&gt;iDev = IO_EXP; // Set which device is being accessed
me-&gt;addrStart = IOE16_REG_GPMR_LSB;
me-&gt;addrSize  = I2C_getI2C1MemAddrSize(me-&gt;iDev);
me-&gt;bytesTotal = 1;
me-&gt;i2cDevOp = I2C_OP_REG_READ;</action>
       <tran_glyph conn="6,72,3,3,43">
        <action box="0,-2,23,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="6,7,21,220">
       <entry box="1,2,5,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="2,3,178,226">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="183,230"/>
   </statechart>
  </class>
  <attribute name="AO_I2C1DevMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="I2C1DevMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for I2C1DevMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param [in]: none.
 * @retval: none
 */</documentation>
   <code>I2C1DevMgr *me = &amp;l_I2C1DevMgr;

QActive_ctor( &amp;me-&gt;super, (QStateHandler)&amp;I2C1DevMgr_initial );
QTimeEvt_ctor( &amp;me-&gt;i2cTimerEvt, I2C1_DEV_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cOpTimerEvt, I2C1_DEV_OP_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cWriteTimerEvt, EEPROM_POST_WRITE_TIMER_SIG );

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);

dbg_slow_printf(&quot;Constructor\n&quot;);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="I2C1DevMgr_gen.c">
   <text>/**
 * @file    I2C1DevMgr.c
 * @brief   Declarations for functions for the I2C1DevMgr AO.
 * This state machine handles any device that is attached to the I2C1 bus.
 * This AO doesn't handle the low level I2C commands and instead communicates
 * with I2CBusMgr AO to send the events that kick off the low level I2C cmds.
 * The rationale behind this is that different I2C devices require different
 * I2C commands in different order.  Some EEPROMs request 2 Start bits, some
 * other devices have different timeouts for their write/read commands. This
 * way, the I2C bus logic can stay common and any device differences are
 * handled in the device specific AOs.
 *
 * @note 1: If editing this file, please make sure to update the I2C1DevMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    10/24/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;I2C1DevMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp_defs.h&quot;     /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include &quot;i2c.h&quot;                                  /* For I2C bus declarations */
#include &quot;i2c_dev.h&quot;                           /* For I2C device declarations */
#include &quot;I2CBusMgr.h&quot;
#include &quot;stm324x9i_eval_ioe16.h&quot;

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_I2C ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::I2C1DevMgr)

/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static I2C1DevMgr l_I2C1DevMgr;   /* the single instance of the active object */

/* Global-scope objects ----------))------------------------------------------*/
QActive * const AO_I2C1DevMgr = (QActive *)&amp;l_I2C1DevMgr;/**&lt; &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::I2C1DevMgr_ctor)
$define(AOs::I2C1DevMgr)

/**
 * @} end addtogroup groupI2C
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="I2C1DevMgr_gen.h">
   <text>/**
 * @file    I2C1DevMgr.h
 * @brief   Declarations for functions for the I2C1DevMgr AO.
 * This state machine handles any device that is attached to the I2C1 bus.
 * This AO doesn't handle the low level I2C commands and instead communicates
 * with I2CBusMgr AO to send the events that kick off the low level I2C cmds.
 * The rationale behind this is that different I2C devices require different
 * I2C commands in different order.  Some EEPROMs request 2 Start bits, some
 * other devices have different timeouts for their write/read commands. This
 * way, the I2C bus logic can stay common and any device differences are
 * handled in the device specific AOs.
 *
 * @note 1: If editing this file, please make sure to update the I2C1DevMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    10/24/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef I2C1DEVMGR_H_
#define I2C1DEVMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;                                   /*  Common Declarations */
#include &quot;i2c.h&quot;

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::I2C1DevMgr_ctor)
$declare(AOs::AO_I2C1DevMgr)

/**
 * @} end addtogroup groupI2C
 */
#endif                                                       /* I2C1DEVMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
