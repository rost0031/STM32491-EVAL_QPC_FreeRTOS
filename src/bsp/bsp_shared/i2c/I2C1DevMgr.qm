<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="I2CReadReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a raw memory read request.
 */</documentation>
   <attribute name="addr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Internal memory address of the I2C device*/</documentation>
   </attribute>
   <attribute name="bytes" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specify how many bytes to read */</documentation>
   </attribute>
   <attribute name="accessType" type="AccessType_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies whether the request came from FreeRTOS thread or another AO */</documentation>
   </attribute>
   <attribute name="i2cDev" type="I2C_Dev_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device to read */</documentation>
   </attribute>
  </class>
  <class name="I2CWriteReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a memory write request.
 */</documentation>
   <attribute name="addr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Internal memory address of the I2C device*/</documentation>
   </attribute>
   <attribute name="bytes" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specify how many bytes to read */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_I2C_READ_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data. */</documentation>
   </attribute>
   <attribute name="accessType" type="AccessType_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies whether the request came from FreeRTOS thread or another AO */</documentation>
   </attribute>
   <attribute name="i2cDev" type="I2C_Dev_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device to read */</documentation>
   </attribute>
  </class>
  <class name="I2CReadDoneEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a memory write request.
 */</documentation>
   <attribute name="bytes" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specify how many bytes to read */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_I2C_READ_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data. */</documentation>
   </attribute>
   <attribute name="status" type="CBErrorCode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the operation */</documentation>
   </attribute>
   <attribute name="i2cDev" type="I2C_Dev_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device was accessed */</documentation>
   </attribute>
  </class>
  <class name="I2CWriteDoneEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a memory write request.
 */</documentation>
   <attribute name="bytes" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specify how many bytes to read */</documentation>
   </attribute>
   <attribute name="status" type="CBErrorCode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the operation */</documentation>
   </attribute>
   <attribute name="i2cDev" type="I2C_Dev_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C device was accessed */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="I2C1DevMgr" superclass="qpc::QActive">
   <documentation>/**
 * @brief I2C1DevMgr Active Object (AO) &quot;class&quot; that manages the all the I2C
 * devices on the I2C1 Bus.
 * This AO manages the devices connected to the I2C1 bus and all events a
 * ssociated with those devices. It deesn't access to the I2C1 bus directly and
 * instead communicates with the I2CBusMgr AO to request and monitor the direct
 * I2C commands that need to be sent down that are specific for the device that
 * is currently being handled.  See I2CDevMgr.qm for diagram and model.
 */</documentation>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="iDev" type="I2C_Dev_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies which I2CBus1 device is currently being handled by this AO.
 * This should be set when a new I2C_READ_START or I2C_WRITE_START events come
 * in.  Those events should contain the device for which they are meant for. */</documentation>
   </attribute>
   <attribute name="iBus" type="I2C_Bus_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which I2C bus this AO is responsible for.  This variable is set on
     startup and is used to index into the structure that holds all the
     I2C bus settings. */</documentation>
   </attribute>
   <attribute name="i2cTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout overall I2C device interactions. */</documentation>
   </attribute>
   <attribute name="i2cOpTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout discrete I2C bus requests to the I2C1DevMgr AO. */</documentation>
   </attribute>
   <attribute name="bytesTotal" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Total number of bytes to be read or written with an operation */</documentation>
   </attribute>
   <attribute name="addrStart" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the starting internal memory address of a read or a
 write operation */</documentation>
   </attribute>
   <attribute name="addrSize" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Number of bytes the &quot;address&quot; variables are */</documentation>
   </attribute>
   <attribute name="addrCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the last memory location accessed.  This is for R/W operations
 * that don't fit into a single bus request */</documentation>
   </attribute>
   <attribute name="errorCode" type="CBErrorCode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of last error that occurs. */</documentation>
   </attribute>
   <attribute name="i2cDevOp" type="I2C_Operation_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of whether a read, write or other was requested */</documentation>
   </attribute>
   <attribute name="i2cWriteTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to time post EEPROM writes. */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_I2C_READ_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data for reads and writes.  It's set to a larger of the
 * I2C sizes since reads can be large while the writes have to be broken into 
 * page sized chunks. */</documentation>
   </attribute>
   <attribute name="accessType" type="AccessType_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies whether the request came from FreeRTOS thread or another AO.  This
     variable keeps track of whether the response needs to get added to the raw
     queue used to communicate with the FreeRTOS thread. */</documentation>
   </attribute>
   <attribute name="writeSizeFirstPage" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of how many bytes to write on the first page of the device */</documentation>
   </attribute>
   <attribute name="writeSizeLastPage" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of how many bytes to write on the last page of the device */</documentation>
   </attribute>
   <attribute name="writeTotalPages" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of how many pages to write to the device */</documentation>
   </attribute>
   <attribute name="writeCurrPage" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of current page to write to the device */</documentation>
   </attribute>
   <attribute name="writeSizeCurr" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; To keep track of how many bytes to write each iteration to the device */</documentation>
   </attribute>
   <attribute name="writeMemAddrCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the current address to write to */</documentation>
   </attribute>
   <attribute name="writeBufferIndex" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the index into the buffer of data when writing several pages */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/1">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

me-&gt;iBus = I2CBus1;          /* This AO only handles devices on I2CBus1 */

QS_OBJ_DICTIONARY(&amp;l_I2C1DevMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;I2C1DevMgr_initial);
QS_FUN_DICTIONARY(&amp;I2C1DevMgr_Active);
QS_FUN_DICTIONARY(&amp;I2C1DevMgr_Idle);

QActive_subscribe((QActive *)me, I2C1_DEV_RAW_MEM_WRITE_SIG);
QActive_subscribe((QActive *)me, I2C1_DEV_RAW_MEM_READ_SIG);

me-&gt;accessType = ACCESS_QPC; /* Init to safe value */</action>
     <initial_glyph conn="1,2,4,3,9,4">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and 
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Post and disarm all the timer events so they can be rearmed at any time */
QTimeEvt_postIn(
    &amp;me-&gt;i2cTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);
QTimeEvt_disarm(&amp;me-&gt;i2cTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cOpTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);
QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;i2cWriteTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);
QTimeEvt_disarm(&amp;me-&gt;i2cWriteTimerEvt);</entry>
     <state name="Busy">
      <documentation>/**
 * @brief   This state indicates that the I2C is currently busy and cannot
 * process incoming data; incoming events will be deferred in this state and
 * handled once the AO goes back to Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;i2cTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_DEV_REQ )
);</entry>
      <exit>QTimeEvt_disarm( &amp;me-&gt;i2cTimerEvt ); /* Disarm timer on exit */

/* If an error occurred, figure out what operation was being 
   done and send the appropriate done event */
if ( ERR_NONE != me-&gt;errorCode ) {
    ERR_printf(&quot;Exiting busy state with error code: 0x%08x\n&quot;, me-&gt;errorCode);
    if ( I2C_OP_MEM_READ == me-&gt;i2cDevOp ) {
        I2CReadDoneEvt *i2cReadDoneEvt = Q_NEW(I2CReadDoneEvt, I2C1_DEV_READ_DONE_SIG);
        i2cReadDoneEvt-&gt;status = me-&gt;errorCode;
        i2cReadDoneEvt-&gt;bytes = 0;
        i2cReadDoneEvt-&gt;i2cDev = me-&gt;iDev;
        QF_PUBLISH((QEvt *)i2cReadDoneEvt, AO_I2C1DevMgr);
    } else if ( I2C_OP_MEM_WRITE == me-&gt;i2cDevOp ) {
        I2CWriteDoneEvt *i2cWriteDoneEvt = Q_NEW(I2CWriteDoneEvt, I2C1_DEV_WRITE_DONE_SIG);
        i2cWriteDoneEvt-&gt;status = me-&gt;errorCode;
        i2cWriteDoneEvt-&gt;bytes = 0;
        i2cWriteDoneEvt-&gt;i2cDev = me-&gt;iDev;
        QF_PUBLISH((QEvt *)i2cWriteDoneEvt, AO_I2C1DevMgr);
    } else {
        WRN_printf(&quot;Unimplemented I2C operation: %d, not sending a response\n&quot;, me-&gt;i2cDevOp);
    }
}</exit>
      <tran trig="I2C1_DEV_TIMEOUT" target="../../1">
       <action>ERR_printf(&quot;I2C1Dev timeout occurred with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
       <tran_glyph conn="54,11,3,1,-28">
        <action box="-17,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C1_DEV_RAW_MEM_READ, I2C1_DEV_RAW_MEM_WRITE">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
   DBG_printf(&quot;Deferring I2C request until current is done\n&quot;);
} else {
   /* notify the request sender that the request was ignored.. */
   ERR_printf(&quot;Unable to defer I2C request\n&quot;);
}</action>
       <tran_glyph conn="54,72,3,-1,43">
        <action box="0,-4,23,4"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C1_DEV_OP_TIMEOUT" target="../../1">
       <action>ERR_printf(&quot;I2C1Dev Op timeout occurred with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
       <tran_glyph conn="54,13,3,1,-28">
        <action box="-20,-2,21,2"/>
       </tran_glyph>
      </tran>
      <state name="GenerateStart">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);

DBG_printf(&quot;ActivePosted I2C_BUS_START_BIT\n&quot;);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="102,22,4,1,5,-76">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../4">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <choice_glyph conn="102,22,5,3,5,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="88,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="88,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrTxMode">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getDevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getDevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="124,22,4,1,6,-98">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../5">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <choice_glyph conn="124,22,5,3,5,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="110,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="110,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="SendInternalAddr">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV8_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV8 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_DEV_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = me-&gt;addrStart;
i2cAddrEvt-&gt;addrSize     = I2C_getMemAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Transmitter;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="146,22,4,1,7,-120">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <choice target="../../../../6">
          <guard brief="Read?">I2C_OP_MEM_READ == me-&gt;i2cDevOp || I2C_OP_REG_READ == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="154,22,4,0,10,-86,2">
           <action box="-6,10,7,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../9">
          <guard brief="Write?">I2C_OP_MEM_WRITE == me-&gt;i2cDevOp || I2C_OP_REG_WRITE == me-&gt;i2cDevOp</guard>
          <choice_glyph conn="154,22,4,3,-7,7">
           <action box="0,-9,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="146,22,5,-1,8">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="132,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="132,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="GenerateStart1">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV5_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV5 )
);

/* Directly post an event to the appropriate I2CBusMgr AO */
static QEvt const qEvt = { I2C_BUS_START_BIT_SIG, 0U, 0U };
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], &amp;qEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="80,44,4,1,5,-54">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../7">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <choice_glyph conn="80,44,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="66,44,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="66,34,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="Send7BitAddrRxMode">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_EV6_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_EV6 )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CAddrEvt *i2cAddrEvt   = Q_NEW( I2CAddrEvt, I2C_BUS_SEND_7BIT_ADDR_SIG );
i2cAddrEvt-&gt;i2cBus       = me-&gt;iBus;
i2cAddrEvt-&gt;addr         = I2C_getDevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize     = I2C_getDevAddrSize(me-&gt;iDev);
i2cAddrEvt-&gt;i2cDirection = I2C_Direction_Receiver;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cAddrEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="104,44,4,1,6,-78">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../8">
         <guard brief="NoErr?">ERR_NONE == ((I2CStatusEvt const *)e)-&gt;errorCode</guard>
         <choice_glyph conn="104,44,5,3,8,1,2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="90,44,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="90,34,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="ReadMem">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_READ_MEM_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_READ )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CReadMemReqEvt *i2cReadMemEvt = Q_NEW( I2CReadMemReqEvt, I2C_BUS_READ_MEM_SIG );
i2cReadMemEvt-&gt;i2cBus           = me-&gt;iBus;
i2cReadMemEvt-&gt;addr             = me-&gt;addrStart;
i2cReadMemEvt-&gt;addrSize         = I2C_getMemAddrSize(me-&gt;iDev);
i2cReadMemEvt-&gt;memAccessType    = I2C_MEM_DMA;
i2cReadMemEvt-&gt;bytes            = me-&gt;bytesTotal;
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cReadMemEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="128,44,4,1,7,-102">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="NoErr?">ERR_NONE == ((I2CBusDataEvt const *)e)-&gt;errorCode</guard>
         <action>/* Set this so the state machine remembers the result */
me-&gt;errorCode = ERR_NONE;
LOG_printf(&quot;Got I2C_BUS_DONE with no error\n&quot;);

I2CReadDoneEvt *i2cReadDoneEvt = Q_NEW(I2CReadDoneEvt, I2C1_DEV_READ_DONE_SIG);
i2cReadDoneEvt-&gt;status = me-&gt;errorCode;
i2cReadDoneEvt-&gt;i2cDev = me-&gt;iDev;
i2cReadDoneEvt-&gt;bytes  = ((I2CBusDataEvt const *)e)-&gt;dataLen;
MEMCPY(
    i2cReadDoneEvt-&gt;dataBuf,
    ((I2CBusDataEvt const *)e)-&gt;dataBuf,
    i2cReadDoneEvt-&gt;bytes
);
QF_PUBLISH((QEvt *)i2cReadDoneEvt, AO_I2C1DevMgr);</action>
         <choice_glyph conn="128,44,5,1,9,11,-111">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="114,44,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="114,34,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WriteMem">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_WRITE_MEM_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_WRITE )
);

/* Allocate and directly post an event to the appropriate I2CBusMgr AO */
I2CWriteMemReqEvt *i2cWriteMemReqEvt = Q_NEW( I2CWriteMemReqEvt, I2C_BUS_WRITE_MEM_SIG );
i2cWriteMemReqEvt-&gt;i2cBus           = me-&gt;iBus;
i2cWriteMemReqEvt-&gt;addr             = me-&gt;writeMemAddrCurr;
i2cWriteMemReqEvt-&gt;addrSize         = I2C_getMemAddrSize(me-&gt;iDev);
i2cWriteMemReqEvt-&gt;memAccessType    = I2C_MEM_DMA;
i2cWriteMemReqEvt-&gt;bytes            = me-&gt;writeSizeCurr;
MEMCPY(
    i2cWriteMemReqEvt-&gt;dataBuf,
    &amp;me-&gt;dataBuf[me-&gt;writeBufferIndex],
    i2cWriteMemReqEvt-&gt;bytes
);
DBG_printf(&quot;QACTPosting I2C_BUS_WRITE_MEM_SIG with %d bytes\n&quot;, i2cWriteMemReqEvt-&gt;bytes );
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)i2cWriteMemReqEvt, me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;
DBG_printf(&quot;Got I2C_BUS_DONE with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="175,22,4,1,8,-17,22,-132">
          <action box="-6,6,7,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../10">
         <guard brief="NoErr?">ERR_NONE == me-&gt;errorCode</guard>
         <choice_glyph conn="175,22,5,1,13,19,-2">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="161,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="161,12,18,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="PostWriteWait">
       <entry>/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cWriteTimerEvt,
    MS_TO_TICKS( HL_MAX_TIME_MS_I2C_POST_WRITE )
);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cWriteTimerEvt);</exit>
       <tran trig="I2C1_DEV_POST_WRITE_TIMER">
        <action>LOG_printf(&quot;Write to EEPROM finished with error: 0x%08x\n&quot;, me-&gt;errorCode);

/* Update the counter and index */
me-&gt;writeMemAddrCurr += me-&gt;writeSizeCurr;
me-&gt;writeBufferIndex += me-&gt;writeSizeCurr;
me-&gt;writeCurrPage    += 1;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <action>LOG_printf(
    &quot;Wrote %d pages to %s. Error: 0x%08x\n&quot;,
    me-&gt;writeTotalPages,
    I2C_devToStr(me-&gt;iDev),
    me-&gt;errorCode
);

/* Publish event for anyone who is listening */
I2CWriteDoneEvt *i2cWriteDoneEvt = Q_NEW(I2CWriteDoneEvt, I2C1_DEV_WRITE_DONE_SIG);
i2cWriteDoneEvt-&gt;status = me-&gt;errorCode;
i2cWriteDoneEvt-&gt;i2cDev = me-&gt;iDev;
i2cWriteDoneEvt-&gt;bytes  = me-&gt;bytesTotal;
QF_PUBLISH((QEvt *)i2cWriteDoneEvt, AO_I2C1DevMgr);</action>
         <choice_glyph conn="58,59,5,1,-32">
          <action box="-10,0,6,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../11">
         <guard brief="MorePages?">me-&gt;writeCurrPage &lt; me-&gt;writeTotalPages</guard>
         <action>if ( me-&gt;writeCurrPage == me-&gt;writeTotalPages-1 ) {
    me-&gt;writeSizeCurr = me-&gt;writeSizeLastPage;
} else {
    me-&gt;writeSizeCurr = I2C_getPageSize( me-&gt;iDev );
}</action>
         <choice_glyph conn="58,59,4,3,-36,8">
          <action box="0,-3,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="162,47,3,-1,26,12,-130">
         <action box="0,-2,24,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="162,37,24,12">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="CheckingBus">
       <entry>/* Set error code */
me-&gt;errorCode = ERR_I2C1DEV_CHECK_BUS_TIMEOUT;

/* Set timer */
QTimeEvt_rearm(
    &amp;me-&gt;i2cOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_I2C_BUS_CHECK )
);

/* Allocate a dynamic event to send back the result after attempting to recover
 * the I2C bus. */
I2CAddrEvt *i2cAddrEvt = Q_NEW( I2CAddrEvt, I2C_BUS_CHECK_FREE_SIG );
i2cAddrEvt-&gt;i2cBus     = me-&gt;iBus;
i2cAddrEvt-&gt;addr       = I2C_getDevAddr(me-&gt;iDev);
i2cAddrEvt-&gt;addrSize   = I2C_getDevAddrSize(me-&gt;iDev);
QACTIVE_POST(AO_I2CBusMgr[me-&gt;iBus], (QEvt *)(i2cAddrEvt), me);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;i2cOpTimerEvt);</exit>
       <tran trig="I2C_BUS_DONE">
        <action>/* Remember the result of each event coming back from I2CBusMgr AO */
me-&gt;errorCode = ((I2CStatusEvt const *)e)-&gt;errorCode;</action>
        <choice target="../../../../1">
         <guard>else</guard>
         <choice_glyph conn="80,22,4,1,4,-54">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../3">
         <guard brief="NoErr?">ERR_NONE == me-&gt;errorCode</guard>
         <choice_glyph conn="80,22,5,3,5,1,3">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="66,22,3,-1,14">
         <action box="0,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="66,12,16,13">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="54,7,141,69">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="Idle">
      <documentation>/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 * This state is the default rest state of the state machine and can handle
 * various I2C requests.  Upon entry, it also checks the deferred queue to see
 * if any request events are waiting which were posted while I2C bus was busy.
 * if there are any waiting, it will read them out, which automatically posts
 * them and the state machine will go and handle them.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* recall the request from the private requestQueue */
QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);

DBG_printf(&quot;back in Idle\n&quot;);</entry>
      <tran trig="I2C1_DEV_RAW_MEM_READ" target="../../0/11">
       <action>me-&gt;iDev       = ((I2CReadReqEvt const *)e)-&gt;i2cDev;
me-&gt;addrStart  = ((I2CReadReqEvt const *)e)-&gt;addr;
me-&gt;bytesTotal = ((I2CReadReqEvt const *)e)-&gt;bytes;
me-&gt;accessType = ((I2CReadReqEvt const *)e)-&gt;accessType;
me-&gt;addrSize   = I2C_getMemAddrSize(me-&gt;iDev);
me-&gt;i2cDevOp   = I2C_OP_MEM_READ;</action>
       <tran_glyph conn="5,15,3,3,61">
        <action box="0,-2,23,2"/>
       </tran_glyph>
      </tran>
      <tran trig="I2C1_DEV_RAW_MEM_WRITE">
       <action>/* Store all the data from the event and look up a few things */
me-&gt;iDev       = ((I2CWriteReqEvt const *)e)-&gt;i2cDev;
me-&gt;addrStart  = ((I2CWriteReqEvt const *)e)-&gt;addr;
me-&gt;bytesTotal = ((I2CWriteReqEvt const *)e)-&gt;bytes;
me-&gt;addrSize   = I2C_getMemAddrSize(me-&gt;iDev);
me-&gt;i2cDevOp   = I2C_OP_MEM_WRITE;
me-&gt;accessType = ((I2CWriteReqEvt const *)e)-&gt;accessType;
MEMCPY(
    me-&gt;dataBuf,
    ((I2CWriteReqEvt const *)e)-&gt;dataBuf,
    me-&gt;bytesTotal
);

/* Figure out the write sizes of pages if number of bytes desired to be written is
 bigger than the page size. */
me-&gt;errorCode = I2C_calcPageWriteSizes(
    &amp;(me-&gt;writeSizeFirstPage),
    &amp;(me-&gt;writeSizeLastPage),
    &amp;(me-&gt;writeTotalPages),
    me-&gt;addrStart,
    me-&gt;bytesTotal,
    I2C_getPageSize( me-&gt;iDev )
);

DBG_printf(
    &quot;wsFP: %d, wsLP: %d, wsTP: %d, aS: 0x%02x, bT: %d\n&quot;,
    me-&gt;writeSizeFirstPage,
    me-&gt;writeSizeLastPage,
    me-&gt;writeTotalPages,
    me-&gt;addrStart,
    me-&gt;bytesTotal
);</action>
       <choice target="../../../0/11">
        <guard brief="NoErr?">ERR_NONE == me-&gt;errorCode</guard>
        <action>/* This is the first iteration through the &quot;loop&quot; which writes several pages */
me-&gt;writeCurrPage    = 0;
me-&gt;writeSizeCurr    = me-&gt;writeSizeFirstPage;
me-&gt;writeBufferIndex = 0;
me-&gt;writeMemAddrCurr = me-&gt;addrStart;</action>
        <choice_glyph conn="32,18,5,3,32,0,2">
         <action box="1,0,10,2"/>
        </choice_glyph>
       </choice>
       <choice target="../..">
        <guard>else</guard>
        <action>ERR_printf(&quot;Unable to calculate page boundaries, aborting write. Error: 0x%08x\n&quot;, me-&gt;errorCode);
I2CWriteDoneEvt *i2cWriteDoneEvt = Q_NEW(I2CWriteDoneEvt, I2C1_DEV_WRITE_DONE_SIG);
i2cWriteDoneEvt-&gt;status = me-&gt;errorCode;
i2cWriteDoneEvt-&gt;bytes = 0;
i2cWriteDoneEvt-&gt;i2cDev = me-&gt;iDev;
QF_PUBLISH((QEvt *)i2cWriteDoneEvt, AO_I2C1DevMgr);</action>
        <choice_glyph conn="32,18,4,1,7,-6">
         <action box="-5,2,6,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="5,18,3,-1,27">
        <action box="0,-2,22,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="5,7,21,69">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,3,194,76">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="200,83"/>
   </statechart>
  </class>
  <attribute name="AO_I2C1DevMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="I2C1DevMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for I2C1DevMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param [in]: none.
 * @retval: none
 */</documentation>
   <code>I2C1DevMgr *me = &amp;l_I2C1DevMgr;

QActive_ctor( &amp;me-&gt;super, (QStateHandler)&amp;I2C1DevMgr_initial );
QTimeEvt_ctor( &amp;me-&gt;i2cTimerEvt, I2C1_DEV_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cOpTimerEvt, I2C1_DEV_OP_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;i2cWriteTimerEvt, I2C1_DEV_POST_WRITE_TIMER_SIG );

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);

dbg_slow_printf(&quot;Constructor\n&quot;);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="I2C1DevMgr_gen.c">
   <text>/**
 * @file    I2C1DevMgr.c
 * @brief   Declarations for functions for the I2C1DevMgr AO.
 * This state machine handles any device that is attached to the I2C1 bus.
 * This AO doesn't handle the low level I2C commands and instead communicates
 * with I2CBusMgr AO to send the events that kick off the low level I2C cmds.
 * The rationale behind this is that different I2C devices require different
 * I2C commands in different order.  Some EEPROMs request 2 Start bits, some
 * other devices have different timeouts for their write/read commands. This
 * way, the I2C bus logic can stay common and any device differences are
 * handled in the device specific AOs.
 *
 * @note 1: If editing this file, please make sure to update the I2C1DevMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    10/24/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;I2C1DevMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp_defs.h&quot;     /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include &quot;i2c.h&quot;                                  /* For I2C bus declarations */
#include &quot;i2c_dev.h&quot;                           /* For I2C device declarations */
#include &quot;I2CBusMgr.h&quot;

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_I2C_DEV ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::I2C1DevMgr)

/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static I2C1DevMgr l_I2C1DevMgr;   /* the single instance of the active object */

/* Global-scope objects ----------))------------------------------------------*/
QActive * const AO_I2C1DevMgr = (QActive *)&amp;l_I2C1DevMgr;/**&lt; &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::I2C1DevMgr_ctor)
$define(AOs::I2C1DevMgr)

/**
 * @} end addtogroup groupI2C
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="I2C1DevMgr_gen.h">
   <text>/**
 * @file    I2C1DevMgr.h
 * @brief   Declarations for functions for the I2C1DevMgr AO.
 * This state machine handles any device that is attached to the I2C1 bus.
 * This AO doesn't handle the low level I2C commands and instead communicates
 * with I2CBusMgr AO to send the events that kick off the low level I2C cmds.
 * The rationale behind this is that different I2C devices require different
 * I2C commands in different order.  Some EEPROMs request 2 Start bits, some
 * other devices have different timeouts for their write/read commands. This
 * way, the I2C bus logic can stay common and any device differences are
 * handled in the device specific AOs.
 *
 * @note 1: If editing this file, please make sure to update the I2C1DevMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    10/24/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef I2C1DEVMGR_H_
#define I2C1DEVMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;                                   /*  Common Declarations */
#include &quot;i2c.h&quot;

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::I2C1DevMgr_ctor)
$declare(AOs::AO_I2C1DevMgr)

/**
 * @} end addtogroup groupI2C
 */
#endif                                                       /* I2C1DEVMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
