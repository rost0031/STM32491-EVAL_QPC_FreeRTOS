/*****************************************************************************
* Model: I2C1DevMgr.qm
* File:  ./I2C1DevMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::I2C1DevMgr_gen.c} ...................................................*/
/**
 * @file    I2C1DevMgr.c
 * @brief   Declarations for functions for the I2C1DevMgr AO.
 * This state machine handles any device that is attached to the I2C1 bus.
 * This AO doesn't handle the low level I2C commands and instead communicates
 * with I2CBusMgr AO to send the events that kick off the low level I2C cmds.
 * The rationale behind this is that different I2C devices require different
 * I2C commands in different order.  Some EEPROMs request 2 Start bits, some
 * other devices have different timeouts for their write/read commands. This
 * way, the I2C bus logic can stay common and any device differences are
 * handled in the device specific AOs.
 *
 * @note 1: If editing this file, please make sure to update the I2C1DevMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    10/24/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupI2C
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "I2C1DevMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp.h"          /* For seconds to bsp tick conversion (SEC_TO_TICK) */

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_I2C ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/

/**
 * @brief I2C1DevMgr Active Object (AO) "class" that manages the all the I2C
 * devices on the I2C1 Bus.
 * This AO manages the devices connected to the I2C1 bus and all events a
 * ssociated with those devices. It deesn't access to the I2C1 bus directly and
 * instead communicates with the I2CBusMgr AO to request and monitor the direct
 * I2C commands that need to be sent down that are specific for the device that
 * is currently being handled.  See I2CDevMgr.qm for diagram and model.
 */
/*${AOs::I2C1DevMgr} .......................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< QPC timer Used to timeout I2C transfers if errors occur. */
    QTimeEvt i2cTimerEvt;

    /**< Native QF queue for deferred request events. */
    QEQueue deferredEvtQueue;

    /**< Storage for deferred event queue. */
    QTimeEvt const * deferredEvtQSto[100];

    /**< Specifies which I2C device is currently being handled by this AO.  This should
         be set when a new I2C_READ_START or I2C_WRITE_START events come in.  Those
         events should contain the device for which they are meant for. */
    I2C_Device_t iDevice;

    /**< Which I2C bus this AO is responsible for.  This variable is set on
         startup and is used to index into the structure that holds all the
         I2C bus settings. */
    I2C_Bus_t iBus;

    /**< Counter used to manually timeout some I2C operations.  Though we supposed to
         not do blocking operations like this, it's unavoidable in this case since
         the I2C ISRs won't post events until they are cleared, which happens after
         here in the AO so nothing moves forward.  With all the delays introduced by
         just event handling, there should be no blocking in reality but just in case,
         there will still be timeout events launched from these loops if this counter
         gets to 0. */
    uint32_t nI2CLoopTimeout;

    /**< QPC timer Used to time I2C DMA operations. */
    QTimeEvt i2cDMATimerEvt;

    /**< Specifies what the current I2C bus operation is happening.  Gets set upon
         reception of I2C_READ_START_SIG and I2C_WRITE_START_SIG */
    I2C_Operation_t i2cCurrOperation;

    /**< QPC timer Used to timeout I2C bus recovery wait states. */
    QTimeEvt i2cRecoveryTimerEvt;
} I2C1DevMgr;

/* protected: */
static QState I2C1DevMgr_initial(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_Active(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief   This state indicates that the I2C is currently busy and cannot
 * process incoming data; incoming events will be deferred in this state and
 * handled once the AO goes back to Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_Busy(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state initiates I2C bus recovery.
 * The bus can become stuck if slave device is misbehaving (or not correctly
 * implementing I2C protocol, or simply by being buggy). Most problems on the
 * I2C bus are caused by a timing issue of the STOP bit being sent and the slave
 * ends up locking the bus waiting for the STOP bit to arrive while the bus
 * master is unable to send it.  The only way to really resolve the issue is to
 * either reset the slave (not always possible) or to manually clock the bits in.
 *
 * This state does exactly that.  Upon entry, it changes the GPIO from I2C
 * configuration to regular GPIO and manually toggles the SCL line until the
 * SDA line is released by the slave.
 * On exit, this state reconfigures the GPIO back to I2C configuration.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitForBusRecovery(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state manually toggles SCL line for I2C bus recovery.
 * The bus can become stuck if slave device is misbehaving (or not correctly
 * implementing I2C protocol, or simply by being buggy). Most problems on the
 * I2C bus are caused by a timing issue of the STOP bit being sent and the slave
 * ends up locking the bus waiting for the STOP bit to arrive while the bus
 * master is unable to send it.  The only way to really resolve the issue is to
 * either reset the slave (not always possible) or to manually clock the bits in.
 *
 * This state manually toggles the SCL line until the SDA line is released
 * by the slave.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_TogglingSCL(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state is a parent state that indicates that the I2C bus is busy.
 *
 * Upon entry to this state, a START bit is generated on the I2C bus which
 * makes it impossible for any other devices to talk on it.  Any new READ or
 * WRITE requests will be deferred until the state machine is back in Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_BusBeingUsed(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV6).
 *
 * This state posts an event to check for the
 * I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6) which is triggerred by
 * sending the 7 bit address to the device in the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If EV6 occurred, the state decides whether to send a 2 or 1 byte address to
 * the slave device and sends the address internal memory address of the device
 * from where we want to read/write.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV6(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for interrupt driven setup of the I2C bus.
 *
 * This state simply listense for events posted from the I2C event ISR.  It's only
 * here for experimentation purposes and is not currently used.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_SetupI2CDevice(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state is a parent state that indicates that the I2C bus is writing.
 *
 * This state contains a handler for the I2C_WRITE_DONE_SIG which will be
 * posted when either the manual byte write or the DMA write are finished.
 *
 * @note: currently, the state machine contains both ways of writing I2C data:
 * DMA and manual byte polling.  Only one is used and it's manually selected by
 * modifying the state machine to use one or the other.  DMA generally works with
 * less processor resources but the single byte method is left in for debugging
 * or experimentation purposes.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_Writing(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for DMA I2C write.
 *
 * This state issues a DMA write command which does all the work and posts a timer
 * to make sure it happens in a timely manner.  The callback from the ISR for the
 * associated DMA stream will post the event with the confirmation event, which
 * will also take the state machine out of this state and back to Idle.
 *
 * @note: this state is WRITE operation specific.
 * @note: some devices on I2C bus, such as EEPROMs, require a post write delay
 * during which the device will not respond to any data. This should be accounted
 * for by the user of this AO since this AO is not device specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitForDMAWriteDone(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for writing I2C bytes manually.
 *
 * This state posts an event to check for the I2C_EVENT_MASTER_BYTE_TRANSMITTED
 * I2C event which indicates that I2C data is ready to be written out.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If data is ready to write, the state machine writes the byte of data and
 * loops back into the state to wait for next I2C event until no more bytes are
 * left to be written.  It then issues a STOP bit on the I2C bus and returns to
 * Idle.
 *
 * @note: this state is WRITE operation specific.
 * @note: some devices on I2C bus, such as EEPROMs, require a post write delay
 * during which the device will not respond to any data. This should be accounted
 * for by the user of this AO since this AO is not device specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WriteI2CByte(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV5).
 *
 * This state posts an event to check for the I2C_EVENT_MASTER_MODE_SELECT (EV5)
 * which is triggerred by posting a START bit on the I2C bus. It also checks if
 * the system is out of retries for this action and exits if true.
 *
 * If the I2C flags indicate that EV5 occurred, the state machine sends the
 * 7 bit address (saved when the I2C_READ/WRITE_START_SIG event started being
 * processed in Idle state) to select the I2C device on the bus. The state machine
 * then goes to the next state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV5(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for EV8 (MSB of the 2 byte address)
 *
 * This state posts an event to check for the
 * I2C_EVENT_MASTER_BYTE_TRANSMITTING (EV8) which is triggerred by
 * sending the MSByte of the memory address of the device in the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If EV8 occurred, the state sends the LSByte of internal memory address of the
 * device from where we want to read/write.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV8_MSB(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for EV8 (LSB of the 2 byte address)
 *
 * This state posts an event to check for the I2C_FLAG_BTF being set (partial EV8)
 * which is triggerred by
 * sending the LSByte (or the only byte) of the memory address of the device in
 * the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If partial EV8 occurred, the state checks if the operation requested is a
 * read or write and goes to the appropriate state based on that.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV8_LSB(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state is a parent state that indicates that the I2C bus is reading.
 *
 * Upon entry to this state, a second START bit is generated on the I2C bus which
 * is required when doing random access reads from most I2C devices.  This state
 * also contains a handler for the I2C_READ_DONE_SIG which will be posted when
 * either the manual byte read or the DMA read are finished.
 *
 * @note: currently, the state machine contains both ways of reading I2C data:
 * DMA and manual byte polling.  Only one is used and it's manually selected by
 * modifying the state machine to use one or the other.  DMA generally works with
 * less processor resources but the single byte method is left in for debugging
 * or experimentation purposes.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_Reading(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV6).
 *
 * This state posts an event to check for the
 * I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6) which is triggerred by
 * sending the 7 bit address to the device in the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If EV6 occurred, the state machine goes to the next state to read actual data
 * from the I2C bus.
 *
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV6_R(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for DMA I2C read.
 *
 * This state issues a DMA read command which does all the work and posts a timer
 * to make sure it happens in a timely manner.  The callback from the ISR for the
 * associated DMA stream will post the event with the read data, which will also
 * take the state machine out of this state and back to Idle.
 *
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitForDMAReadDone(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV5).
 *
 * This state posts an event to check for the I2C_EVENT_MASTER_MODE_SELECT (EV5)
 * which is triggerred by posting a START bit on the I2C bus. It also checks if
 * the system is out of retries for this action and exits if true.
 *
 * If the I2C flags indicate that EV5 occurred, the state machine sends the
 * 7 bit address (saved when the I2C_READ_START_SIG event started being
 * processed in Idle state) to select the I2C device on the bus. The state machine
 * then goes to the next state.
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV5_R(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This is a Wait state for polling for reading I2C bytes manually.
 *
 * This state posts an event to check for the I2C_FLAG_RXNE flag has been set
 * which indicates that I2C data is ready to be read out.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If data is ready to read, the state machine reads the byte of data and stores
 * it in the buffer.  It then checks whether there is 1 byte left to read and if
 * so, issues a STOP bit on the bus.  This is due to a bug in the STM32 I2C IP
 * which requires that the STOP bit be sent before the last byte is read out.
 *
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_ReadI2CByte(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state waits selects I2C master.
 * After a recovering the bus, the it needs to error out properly.  In order to
 * do this, a new communication has to be attempted.  This state initiates the
 * communication as if it is going to talk to a slave EEPROM.  An error is
 * expected and the I2C1_ER_IRQHandler ISR will clear it by calling the
 * I2C1_ErrorEventCallback function.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV5_REC(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state selects I2C transmitter mode.
 * After a recovering the bus, the it needs to error out properly.  In order to
 * do this, a new communication has to be attempted.  This state continues after
 * previous state, because sometimes the error can happen a little later.
 * An error is expected and the I2C1_ER_IRQHandler ISR will clear it by
 * calling the I2C1_ErrorEventCallback function.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitFor_I2C_EV6_REC(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state initiates I2C communication by checking if I2C bus busy
 * flag is set.  If the flag is set, it attempts to recover the bus (see
 * WaitForBusRecovery state for details), otherwise, it continues.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_StartI2CComm(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state waits for the bus to settle after being reconfigured to I2C.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_WaitForBusToSettle(I2C1DevMgr * const me, QEvt const * const e);

/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 * This state is the default rest state of the state machine and can handle
 * various I2C requests.  Upon entry, it also checks the deferred queue to see
 * if any request events are waiting which were posted while I2C bus was busy.
 * if there are any waiting, it will read them out, which automatically posts
 * them and the state machine will go and handle them.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState I2C1DevMgr_Idle(I2C1DevMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static I2C1DevMgr l_I2C1DevMgr;   /* the single instance of the active object */

/* Global-scope objects ----------))------------------------------------------*/
QActive * const AO_I2C1DevMgr = (QActive *)&l_I2C1DevMgr;/* "opaque" AO pointer */
extern I2C_BusSettings_t s_I2C_Bus[MAX_I2C_BUS];
extern I2C_BusDevice_t   s_I2C_Dev[MAX_I2C_DEV];

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for I2C1DevMgr "class".
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param [in]: none.
 * @retval: none
 */
/*${AOs::I2C1DevMgr_ctor} ..................................................*/
void I2C1DevMgr_ctor(void) {
    I2C1DevMgr *me = &l_I2C1DevMgr;

    QActive_ctor( &me->super, (QStateHandler)&I2C1DevMgr_initial );
    QTimeEvt_ctor( &me->i2cTimerEvt, I2C_TIMEOUT_SIG );
    QTimeEvt_ctor( &me->i2cDMATimerEvt, I2C_DMA_TIMEOUT_SIG );
    QTimeEvt_ctor( &me->i2cRecoveryTimerEvt, I2C_RECOVERY_TIMEOUT_SIG );

    /* Initialize the deferred event queue and storage for it */
    QEQueue_init(
        &me->deferredEvtQueue,
        (QEvt const **)( me->deferredEvtQSto ),
        Q_DIM(me->deferredEvtQSto)
    );

    dbg_slow_printf("Constructor\n");
}

/**
 * @brief I2C1DevMgr Active Object (AO) "class" that manages the all the I2C
 * devices on the I2C1 Bus.
 * This AO manages the devices connected to the I2C1 bus and all events a
 * ssociated with those devices. It deesn't access to the I2C1 bus directly and
 * instead communicates with the I2CBusMgr AO to request and monitor the direct
 * I2C commands that need to be sent down that are specific for the device that
 * is currently being handled.  See I2CDevMgr.qm for diagram and model.
 */
/*${AOs::I2C1DevMgr} .......................................................*/
/*${AOs::I2C1DevMgr::SM} ...................................................*/
static QState I2C1DevMgr_initial(I2C1DevMgr * const me, QEvt const * const e) {
    /* ${AOs::I2C1DevMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_I2C1DevMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&I2C1DevMgr_initial);
    QS_FUN_DICTIONARY(&I2C1DevMgr_Active);
    QS_FUN_DICTIONARY(&I2C1DevMgr_Idle);
    QS_FUN_DICTIONARY(&I2C1DevMgr_Busy);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitForBusRecovery);
    QS_FUN_DICTIONARY(&I2C1DevMgr_TogglingSCL);
    QS_FUN_DICTIONARY(&I2C1DevMgr_BusBeingUsed);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV6);
    QS_FUN_DICTIONARY(&I2C1DevMgr_SetupI2CDevice);
    QS_FUN_DICTIONARY(&I2C1DevMgr_Writing);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitForDMAWriteDone);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WriteI2CByte);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV5);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV8_MSB);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV8_LSB);
    QS_FUN_DICTIONARY(&I2C1DevMgr_Reading);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV6_R);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitForDMAReadDone);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV5_R);
    QS_FUN_DICTIONARY(&I2C1DevMgr_ReadI2CByte);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV5_REC);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitFor_I2C_EV6_REC);
    QS_FUN_DICTIONARY(&I2C1DevMgr_StartI2CComm);
    QS_FUN_DICTIONARY(&I2C1DevMgr_WaitForBusToSettle);

    QActive_subscribe((QActive *)me, I2C_READ_START_SIG);
    QActive_subscribe((QActive *)me, I2C_WRITE_START_SIG);
    QActive_subscribe((QActive *)me, I2C_TIMEOUT_SIG);
    QActive_subscribe((QActive *)me, I2C_CHECK_EV_SIG);
    QActive_subscribe((QActive *)me, I2C_READ_DONE_SIG);
    QActive_subscribe((QActive *)me, I2C_WRITE_DONE_SIG);
    QActive_subscribe((QActive *)me, I2C_DMA_TIMEOUT_SIG);
    QActive_subscribe((QActive *)me, I2C_EV_MASTER_MODE_SELECT_SIG);
    QActive_subscribe((QActive *)me, I2C_EV_MASTER_TX_MODE_SELECTED_SIG);
    QActive_subscribe((QActive *)me, I2C_SENT_MSB_ADDR_SIG);
    QActive_subscribe((QActive *)me, I2C_SENT_LSB_ADDR_SIG);
    QActive_subscribe((QActive *)me, I2C_RECOVERY_TIMEOUT_SIG);
    return Q_TRAN(&I2C1DevMgr_Idle);
}

/**
 * @brief This state is a catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active} ...........................................*/
static QState I2C1DevMgr_Active(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Post all the timers and disarm them right away so it can be
             * rearmed at any point without worrying asserts. */
            QTimeEvt_postIn(
                &me->i2cTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
            );
            QTimeEvt_disarm(&me->i2cTimerEvt);

            QTimeEvt_postIn(
                &me->i2cDMATimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_READ_OP_SEC )
            );
            QTimeEvt_disarm(&me->i2cDMATimerEvt);

            QTimeEvt_postIn(
                &me->i2cRecoveryTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUS_RECOVERY_SEC )
            );
            QTimeEvt_disarm(&me->i2cRecoveryTimerEvt);

            /* Initialize the I2C devices and associated busses */
            I2C_BusInit( me->iBus );
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief   This state indicates that the I2C is currently busy and cannot
 * process incoming data; incoming events will be deferred in this state and
 * handled once the AO goes back to Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy} .....................................*/
static QState I2C1DevMgr_Busy(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->i2cTimerEvt,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUSY_SEC )
            );

            /* Set the I2C device state */
            s_I2C_Bus[me->iBus].i2c_cur_st = I2C_IDLE_ST;
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm( &me->i2cTimerEvt ); /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::I2C_TIMEOUT} */
        case I2C_TIMEOUT_SIG: {
            ERR_printf("I2C timeout occurred\n");
            status_ = Q_TRAN(&I2C1DevMgr_Idle);
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::I2C_READ_START, I2C_WRITE_START} */
        case I2C_READ_START_SIG: /* intentionally fall through */
        case I2C_WRITE_START_SIG: {
            if (QEQueue_getNFree(&me->deferredEvtQueue) > 0) {
               /* defer the request - this event will be handled
                * when the state machine goes back to Idle state */
               QActive_defer((QActive *)me, &me->deferredEvtQueue, e);
               DBG_printf("Deferring I2C request until current is done\n");
            } else {
               /* notify the request sender that the request was ignored.. */
               ERR_printf("Unable to defer I2C request\n");
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state initiates I2C bus recovery.
 * The bus can become stuck if slave device is misbehaving (or not correctly
 * implementing I2C protocol, or simply by being buggy). Most problems on the
 * I2C bus are caused by a timing issue of the STOP bit being sent and the slave
 * ends up locking the bus waiting for the STOP bit to arrive while the bus
 * master is unable to send it.  The only way to really resolve the issue is to
 * either reset the slave (not always possible) or to manually clock the bits in.
 *
 * This state does exactly that.  Upon entry, it changes the GPIO from I2C
 * configuration to regular GPIO and manually toggles the SCL line until the
 * SDA line is released by the slave.
 * On exit, this state reconfigures the GPIO back to I2C configuration.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery} .................*/
static QState I2C1DevMgr_WaitForBusRecovery(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery} */
        case Q_ENTRY_SIG: {
            /* Set the pins up for manual toggling */
            I2C_BusInitForRecovery( me->iBus );

            /* Reset the maximum number of times to poll the I2C bus for an event */
            me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;

            WRN_printf("Some I2C%d slave device is misbehaving.\n", (me->iBus) + 1);
            WRN_printf("Attempting to recover bus by toggling the SCL line\n");
            WRN_printf("This may cause data corruption if the last I2C op was a write\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery} */
        case Q_EXIT_SIG: {
            /* Initialize the I2C devices and associated busses */
            LOG_printf("ReInitializing I2C%d bus.\n", (me->iBus) + 1);
            I2C_BusInit( me->iBus );
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state manually toggles SCL line for I2C bus recovery.
 * The bus can become stuck if slave device is misbehaving (or not correctly
 * implementing I2C protocol, or simply by being buggy). Most problems on the
 * I2C bus are caused by a timing issue of the STOP bit being sent and the slave
 * ends up locking the bus waiting for the STOP bit to arrive while the bus
 * master is unable to send it.  The only way to really resolve the issue is to
 * either reset the slave (not always possible) or to manually clock the bits in.
 *
 * This state manually toggles the SCL line until the SDA line is released
 * by the slave.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery::TogglingSCL} ....*/
static QState I2C1DevMgr_TogglingSCL(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery::TogglingSCL} */
        case Q_ENTRY_SIG: {
            /* Toggle the SCL bit of the bus to the opposite value that it is now */
            GPIO_ToggleBits( s_I2C_Bus[me->iBus].scl_port, s_I2C_Bus[me->iBus].scl_pin );

            /* Create event to check event and publish it */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery::TogglingSCL::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if bus is busy.  If free, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery::TogglingSCL::I2C_CHECK_EV::[BusFree?]} */
            if (SET == GPIO_ReadInputDataBit( s_I2C_Bus[me->iBus].sda_port, s_I2C_Bus[me->iBus].sda_pin  )) {
                WRN_printf("Bus free after %d SCL toggles\n", MAX_I2C_TIMEOUT - me->nI2CLoopTimeout);

                /* Make sure to leave the SCL line high after exit */
                GPIO_SetBits( s_I2C_Bus[me->iBus].scl_port, s_I2C_Bus[me->iBus].scl_pin );

                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                status_ = Q_TRAN(&I2C1DevMgr_WaitForBusToSettle);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery::TogglingSCL::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery::TogglingSCL::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_TogglingSCL);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusRecovery::TogglingSCL::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C bus to be free\n");
                    I2C_SoftwareResetCmd(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);
                    I2C_SoftwareResetCmd(s_I2C_Bus[me->iBus].i2c_bus, DISABLE);
                    DBG_printf("I2C bus reset\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_WaitForBusRecovery);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state is a parent state that indicates that the I2C bus is busy.
 *
 * Upon entry to this state, a START bit is generated on the I2C bus which
 * makes it impossible for any other devices to talk on it.  Any new READ or
 * WRITE requests will be deferred until the state machine is back in Idle state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed} .......................*/
static QState I2C1DevMgr_BusBeingUsed(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed} */
        case Q_ENTRY_SIG: {
            DBG_printf("Generating I2C start\n");

            /* Send START condition */
            I2C_GenerateSTART(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV6).
 *
 * This state posts an event to check for the
 * I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6) which is triggerred by
 * sending the 7 bit address to the device in the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If EV6 occurred, the state decides whether to send a 2 or 1 byte address to
 * the slave device and sends the address internal memory address of the device
 * from where we want to read/write.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6} ......*/
static QState I2C1DevMgr_WaitFor_I2C_EV6(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6::I2C_CHECK_EV::[EV6Happened?]} */
            if (I2C_CheckEvent( s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED )) {
                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6::I2C_CHECK_EV::[EV6Happened?]::[2Byteaddr?]} */
                if (2 == I2C_getDevAddrSize(me->iDevice)) {
                    DBG_printf("Sending internal MSB addr to the I2C Device\n");

                    /* Send the MSB of the address first to the I2C device */
                    I2C_SendData(
                        s_I2C_Bus[me->iBus].i2c_bus,
                        (uint8_t)((s_I2C_Dev[me->iDevice].i2c_mem_addr & 0xFF00) >> 8)
                    );

                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV8_MSB);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6::I2C_CHECK_EV::[EV6Happened?]::[1byteaddr?]} */
                else {
                    DBG_printf("Sending internal 1 byte addr to the I2C Device\n");

                    /* Send the single byte address to the device */
                    I2C_SendData(
                        s_I2C_Bus[me->iBus].i2c_bus,
                        (uint8_t)(s_I2C_Dev[me->iDevice].i2c_mem_addr & 0x00FF)
                    );
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV8_LSB);
                }
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV6);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV6::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_BusBeingUsed);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for interrupt driven setup of the I2C bus.
 *
 * This state simply listense for events posted from the I2C event ISR.  It's only
 * here for experimentation purposes and is not currently used.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::SetupI2CDevice} .......*/
static QState I2C1DevMgr_SetupI2CDevice(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::SetupI2CDevice} */
        case Q_ENTRY_SIG: {
            /* Set the I2C device state: generate start bit */
            s_I2C_Bus[me->iBus].i2c_cur_st = I2C_GEN_START_ST;

            /* Set the direction to transmit the address */
            I2C_SetDirection( me->iBus,  I2C_Direction_Transmitter);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::SetupI2CDevice::I2C_EV_MASTER_MODE_SELECT} */
        case I2C_EV_MASTER_MODE_SELECT_SIG: {
            DBG_printf("Got I2C_EV_MASTER_MODE_SELECT\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::SetupI2CDevice::I2C_EV_MASTER_TX_MODE_SELECTED} */
        case I2C_EV_MASTER_TX_MODE_SELECTED_SIG: {
            DBG_printf("Got I2C_EV_MASTER_TX_MODE_SELECTED\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::SetupI2CDevice::I2C_SENT_MSB_ADDR} */
        case I2C_SENT_MSB_ADDR_SIG: {
            DBG_printf("Got I2C_SENT_MSB_ADDR\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::SetupI2CDevice::I2C_SENT_LSB_ADDR} */
        case I2C_SENT_LSB_ADDR_SIG: {
            DBG_printf("Got I2C_SENT_LSB_ADDR\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_BusBeingUsed);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state is a parent state that indicates that the I2C bus is writing.
 *
 * This state contains a handler for the I2C_WRITE_DONE_SIG which will be
 * posted when either the manual byte write or the DMA write are finished.
 *
 * @note: currently, the state machine contains both ways of writing I2C data:
 * DMA and manual byte polling.  Only one is used and it's manually selected by
 * modifying the state machine to use one or the other.  DMA generally works with
 * less processor resources but the single byte method is left in for debugging
 * or experimentation purposes.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing} ..............*/
static QState I2C1DevMgr_Writing(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::I2C_WRITE_DONE} */
        case I2C_WRITE_DONE_SIG: {
            DBG_printf("I2C Write finished successfully: wrote %d bytes\n", ((I2CEvt const *)e)->wDataLen);
            //dbg_slow_printf("Wasting sometime to see if the 2 writes back to back too quickly screw stuff up.  Maybe... but this slow ass serial write should delay stuff quite a bit\n");
            //DBG_printf("I2C waste of time end\n");
            status_ = Q_TRAN(&I2C1DevMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_BusBeingUsed);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for DMA I2C write.
 *
 * This state issues a DMA write command which does all the work and posts a timer
 * to make sure it happens in a timely manner.  The callback from the ISR for the
 * associated DMA stream will post the event with the confirmation event, which
 * will also take the state machine out of this state and back to Idle.
 *
 * @note: this state is WRITE operation specific.
 * @note: some devices on I2C bus, such as EEPROMs, require a post write delay
 * during which the device will not respond to any data. This should be accounted
 * for by the user of this AO since this AO is not device specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WaitForDMAWriteDone} */
static QState I2C1DevMgr_WaitForDMAWriteDone(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WaitForDMAWriteDone} */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->i2cDMATimerEvt,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_DMA_WRITE_SEC )
            );

            /* Start the DMA write operation */
            I2C_StartDMAWrite(
                me->iBus,
                s_I2C_Bus[me->iBus].nBytesExpected
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WaitForDMAWriteDone} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm( &me->i2cDMATimerEvt );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WaitForDMAWriteDone::I2C_DMA_TIMEOUT} */
        case I2C_DMA_TIMEOUT_SIG: {
            ERR_printf("Timeout while waiting for DMA read timeout\n");

            /* TODO: DEBUG STUFF - remove */
            ERR_printf("DMA1_St6 fifo is at %d\n", DMA_GetFIFOStatus(DMA1_Stream6) );
            ERR_printf("DMA1_St6 TC flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_IT_TCIF6) );
            ERR_printf("DMA1_St6 FE flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_FEIF6) );
            ERR_printf("DMA1_St6 DM flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_DMEIF6) );
            ERR_printf("DMA1_St6 TE flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_TEIF6) );
            ERR_printf("DMA1_St6 HT flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_HTIF6) );

            if (DMA_GetCmdStatus(DMA1_Stream6)== ENABLE) {
                ERR_printf("DMA1_Stream6 still enabled, turning off\n");
                DMA_Cmd( DMA1_Stream0, DISABLE );
            }

            /* Disable Acknowledgment */
            I2C_AcknowledgeConfig(s_I2C_Bus[me->iBus].i2c_bus, DISABLE);

            I2C_GenerateSTOP(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);

            /* Re-Enable Acknowledgment to be ready for another reception */
            I2C_AcknowledgeConfig(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);

            DBG_printf("Generating I2C stop\n");
            status_ = Q_TRAN(&I2C1DevMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Writing);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for writing I2C bytes manually.
 *
 * This state posts an event to check for the I2C_EVENT_MASTER_BYTE_TRANSMITTED
 * I2C event which indicates that I2C data is ready to be written out.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If data is ready to write, the state machine writes the byte of data and
 * loops back into the state to wait for next I2C event until no more bytes are
 * left to be written.  It then issues a STOP bit on the I2C bus and returns to
 * Idle.
 *
 * @note: this state is WRITE operation specific.
 * @note: some devices on I2C bus, such as EEPROMs, require a post write delay
 * during which the device will not respond to any data. This should be accounted
 * for by the user of this AO since this AO is not device specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte} */
static QState I2C1DevMgr_WriteI2CByte(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte::I2C_CHECK_EV::[ReadyToWrite?]} */
            if (I2C_CheckEvent(s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte::I2C_CHECK_EV::[ReadyToWrite?]::[Nomorebytes?]} */
                if (0 == (s_I2C_Bus[me->iBus].nBytesExpected - s_I2C_Bus[me->iBus].nTxIndex)) {
                    I2C_GenerateSTOP(I2C1, ENABLE);                        /* Generate Stop */
                    DBG_printf("Done writing I2C data\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte::I2C_CHECK_EV::[ReadyToWrite?]::[else]} */
                else {
                    DBG_printf("Writing 0x%02x byte %d to I2C Device\n",
                        s_I2C_Bus[me->iBus].pTxBuffer[ s_I2C_Bus[me->iBus].nTxIndex ],
                        s_I2C_Bus[me->iBus].nTxIndex
                    );

                    /* Send the single byte address to the device */
                    I2C_SendData(
                        s_I2C_Bus[me->iBus].i2c_bus,
                        s_I2C_Bus[me->iBus].pTxBuffer[ s_I2C_Bus[me->iBus].nTxIndex++ ]
                    );
                    status_ = Q_TRAN(&I2C1DevMgr_WriteI2CByte);
                }
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WriteI2CByte);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Writing::WriteI2CByte::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Writing);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV5).
 *
 * This state posts an event to check for the I2C_EVENT_MASTER_MODE_SELECT (EV5)
 * which is triggerred by posting a START bit on the I2C bus. It also checks if
 * the system is out of retries for this action and exits if true.
 *
 * If the I2C flags indicate that EV5 occurred, the state machine sends the
 * 7 bit address (saved when the I2C_READ/WRITE_START_SIG event started being
 * processed in Idle state) to select the I2C device on the bus. The state machine
 * then goes to the next state.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV5} ......*/
static QState I2C1DevMgr_WaitFor_I2C_EV5(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV5} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV5::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV5 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV5::I2C_CHECK_EV::[EV5Happened?]} */
            if (I2C_CheckEvent(s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_MODE_SELECT)) {
                DBG_printf("Selecting slave I2C Device\n");

                /* Set the direction to transmit the address */
                I2C_SetDirection( me->iBus,  I2C_Direction_Transmitter);

                /* Send slave Address for write */
                I2C_Send7bitAddress(
                    s_I2C_Bus[me->iBus].i2c_bus,            /* This is always the bus used in this ISR */
                    s_I2C_Dev[me->iDevice].i2c_dev_addr,    /* Look up the current device address for this bus */
                    s_I2C_Bus[me->iBus].bTransDirection     /* Direction of data on this bus */
                );

                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV6);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV5::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV5::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV5);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV5::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_MODE_SELECT (EV5)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_BusBeingUsed);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for EV8 (MSB of the 2 byte address)
 *
 * This state posts an event to check for the
 * I2C_EVENT_MASTER_BYTE_TRANSMITTING (EV8) which is triggerred by
 * sending the MSByte of the memory address of the device in the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If EV8 occurred, the state sends the LSByte of internal memory address of the
 * device from where we want to read/write.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_MSB} ..*/
static QState I2C1DevMgr_WaitFor_I2C_EV8_MSB(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_MSB} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_MSB::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_MSB::I2C_CHECK_EV::[EV8Happened?]} */
            if (I2C_CheckEvent( s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_BYTE_TRANSMITTING )) {
                DBG_printf("Sending internal LSB addr to the I2C Device\n");

                /* Send the LSB of the address to the I2C device */
                I2C_SendData(
                    s_I2C_Bus[me->iBus].i2c_bus,
                    (uint8_t)(s_I2C_Dev[me->iDevice].i2c_mem_addr & 0x00FF)
                );

                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV8_LSB);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_MSB::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_MSB::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV8_MSB);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_MSB::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_BYTE_TRANSMITTING (EV8)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_BusBeingUsed);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for EV8 (LSB of the 2 byte address)
 *
 * This state posts an event to check for the I2C_FLAG_BTF being set (partial EV8)
 * which is triggerred by
 * sending the LSByte (or the only byte) of the memory address of the device in
 * the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If partial EV8 occurred, the state checks if the operation requested is a
 * read or write and goes to the appropriate state based on that.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB} ..*/
static QState I2C1DevMgr_WaitFor_I2C_EV8_LSB(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV::[EV8Happened?]} */
            if (SET == I2C_GetFlagStatus(s_I2C_Bus[me->iBus].i2c_bus, I2C_FLAG_BTF)) {
                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV::[EV8Happened?]::[READ?]} */
                if (I2C_OP_READ == me->i2cCurrOperation) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV5_R);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV::[EV8Happened?]::[WRITE?]} */
                else if (I2C_OP_WRITE == me->i2cCurrOperation) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitForDMAWriteDone);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV::[EV8Happened?]::[else]} */
                else {
                    ERR_printf("Invalid I2C operation selected: %d\n", me->i2cCurrOperation);
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV8_LSB);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::WaitFor_I2C_EV8_LSB::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_BYTE_TRANSMITTING (EV8)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_BusBeingUsed);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state is a parent state that indicates that the I2C bus is reading.
 *
 * Upon entry to this state, a second START bit is generated on the I2C bus which
 * is required when doing random access reads from most I2C devices.  This state
 * also contains a handler for the I2C_READ_DONE_SIG which will be posted when
 * either the manual byte read or the DMA read are finished.
 *
 * @note: currently, the state machine contains both ways of reading I2C data:
 * DMA and manual byte polling.  Only one is used and it's manually selected by
 * modifying the state machine to use one or the other.  DMA generally works with
 * less processor resources but the single byte method is left in for debugging
 * or experimentation purposes.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading} ..............*/
static QState I2C1DevMgr_Reading(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading} */
        case Q_ENTRY_SIG: {
            DBG_printf("Sending a second START bit to the I2C Device\n");

            /* Send START condition */
            I2C_GenerateSTART(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::I2C_READ_DONE} */
        case I2C_READ_DONE_SIG: {
            DBG_printf("I2C Read finished successfully: read %d bytes\n", ((I2CDataEvt const *)e)->wDataLen);
            status_ = Q_TRAN(&I2C1DevMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_BusBeingUsed);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV6).
 *
 * This state posts an event to check for the
 * I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6) which is triggerred by
 * sending the 7 bit address to the device in the previous state.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If EV6 occurred, the state machine goes to the next state to read actual data
 * from the I2C bus.
 *
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV6_R} */
static QState I2C1DevMgr_WaitFor_I2C_EV6_R(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV6_R} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV6_R::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV6_R::I2C_CHECK_EV::[EV6Happened?]} */
            if (I2C_CheckEvent( s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED )) {
                DBG_printf("Starting to read the I2C Device data...\n");

                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                status_ = Q_TRAN(&I2C1DevMgr_WaitForDMAReadDone);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV6_R::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV6_R::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV6_R);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV6_R::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Reading);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for DMA I2C read.
 *
 * This state issues a DMA read command which does all the work and posts a timer
 * to make sure it happens in a timely manner.  The callback from the ISR for the
 * associated DMA stream will post the event with the read data, which will also
 * take the state machine out of this state and back to Idle.
 *
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitForDMAReadDone} */
static QState I2C1DevMgr_WaitForDMAReadDone(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitForDMAReadDone} */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->i2cDMATimerEvt,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_DMA_READ_SEC )
            );

            /* Reset the number of bytes already read to 0 */
            s_I2C_Bus[me->iBus].nBytesCurrent = 0;

            /* Start the DMA read operation */
            I2C_StartDMARead(
                me->iBus,
                s_I2C_Bus[me->iBus].nBytesExpected
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitForDMAReadDone} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm( &me->i2cDMATimerEvt );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitForDMAReadDone::I2C_DMA_TIMEOUT} */
        case I2C_DMA_TIMEOUT_SIG: {
            ERR_printf("Timeout while waiting for DMA read timeout\n");

            /* TODO: DEBUG STUFF - remove */
            ERR_printf("DMA1_St0 fifo is at %d\n", DMA_GetFIFOStatus(DMA1_Stream0) );
            ERR_printf("DMA1_St0 TC flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_IT_TCIF0) );
            ERR_printf("DMA1_St0 FE flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_FEIF0) );
            ERR_printf("DMA1_St0 DM flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_DMEIF0) );
            ERR_printf("DMA1_St0 TE flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_TEIF0) );
            ERR_printf("DMA1_St0 HT flag: %d\n", DMA_GetFlagStatus(DMA1_Stream0,DMA_FLAG_HTIF0) );

            if (DMA_GetCmdStatus(DMA1_Stream0)== ENABLE) {
                ERR_printf("DMA1_Stream0 still enabled, turning off\n");
                DMA_Cmd( DMA1_Stream0, DISABLE );
            }

            /* Disable Acknowledgment */
            I2C_AcknowledgeConfig(s_I2C_Bus[me->iBus].i2c_bus, DISABLE);

            I2C_GenerateSTOP(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);

            /* Re-Enable Acknowledgment to be ready for another reception */
            I2C_AcknowledgeConfig(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);

            DBG_printf("Generating I2C stop\n");
            status_ = Q_TRAN(&I2C1DevMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Reading);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for MASTER MODE (I2C EV5).
 *
 * This state posts an event to check for the I2C_EVENT_MASTER_MODE_SELECT (EV5)
 * which is triggerred by posting a START bit on the I2C bus. It also checks if
 * the system is out of retries for this action and exits if true.
 *
 * If the I2C flags indicate that EV5 occurred, the state machine sends the
 * 7 bit address (saved when the I2C_READ_START_SIG event started being
 * processed in Idle state) to select the I2C device on the bus. The state machine
 * then goes to the next state.
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV5_R} */
static QState I2C1DevMgr_WaitFor_I2C_EV5_R(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV5_R} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV5_R::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV5 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV5_R::I2C_CHECK_EV::[EV5Happened?]} */
            if (I2C_CheckEvent(s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_MODE_SELECT)) {
                DBG_printf("Selecting slave I2C Device\n");

                /* Set the direction to receive */
                I2C_SetDirection( me->iBus,  I2C_Direction_Receiver);

                /* Send slave Address for read */
                I2C_Send7bitAddress(
                    s_I2C_Bus[me->iBus].i2c_bus,           /* This is always the bus used in this ISR */
                    s_I2C_Dev[me->iDevice].i2c_dev_addr,   /* Look up the current device address for this bus */
                    s_I2C_Bus[me->iBus].bTransDirection    /* Direction of data on this bus */
                );

                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT * 100;
                status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV6_R);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV5_R::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV5_R::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV5_R);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::WaitFor_I2C_EV5_R::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_MODE_SELECT (EV5)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Reading);
            break;
        }
    }
    return status_;
}

/**
 * @brief This is a Wait state for polling for reading I2C bytes manually.
 *
 * This state posts an event to check for the I2C_FLAG_RXNE flag has been set
 * which indicates that I2C data is ready to be read out.
 * It also checks if the system is out of retries for this action and exits
 * if true.
 * If data is ready to read, the state machine reads the byte of data and stores
 * it in the buffer.  It then checks whether there is 1 byte left to read and if
 * so, issues a STOP bit on the bus.  This is due to a bug in the STM32 I2C IP
 * which requires that the STOP bit be sent before the last byte is read out.
 *
 * @note: this state is READ operation specific.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte} .*/
static QState I2C1DevMgr_ReadI2CByte(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV::[ReadyToRead?]} */
            if (RESET != I2C_GetFlagStatus( s_I2C_Bus[me->iBus].i2c_bus, I2C_FLAG_RXNE )) {
                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;

                s_I2C_Bus[me->iBus].pRxBuffer[s_I2C_Bus[me->iBus].nBytesCurrent++] =
                    I2C_ReceiveData(s_I2C_Bus[me->iBus].i2c_bus);

                /** me->nRead++; Increment number of bytes read */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV::[ReadyToRead?]::[>1byteleft?]} */
                if ((s_I2C_Bus[me->iBus].nBytesExpected - s_I2C_Bus[me->iBus].nBytesCurrent) > 1) {
                    status_ = Q_TRAN(&I2C1DevMgr_ReadI2CByte);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV::[ReadyToRead?]::[1byteleft?]} */
                else if (1 == (s_I2C_Bus[me->iBus].nBytesExpected - s_I2C_Bus[me->iBus].nBytesCurrent)) {
                    DBG_printf("Done Reading\n");
                    I2C_AcknowledgeConfig( I2C1, DISABLE);        /* Disable Acknowledgment */
                    I2C_GenerateSTOP(I2C1, ENABLE);                        /* Generate Stop */
                    status_ = Q_TRAN(&I2C1DevMgr_ReadI2CByte);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV::[ReadyToRead?]::[else]} */
                else {
                    I2C_AcknowledgeConfig(I2C1, ENABLE);        /* Re-enable Acknowledgment */
                    DBG_printf("Done reading I2C data\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_ReadI2CByte);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::BusBeingUsed::Reading::ReadI2CByte::I2C_CHECK_EV::[else]::[else]} */
                else {
                    ERR_printf("Timeout waiting for I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED (EV6)\n");
                    status_ = Q_TRAN(&I2C1DevMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Reading);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state waits selects I2C master.
 * After a recovering the bus, the it needs to error out properly.  In order to
 * do this, a new communication has to be attempted.  This state initiates the
 * communication as if it is going to talk to a slave EEPROM.  An error is
 * expected and the I2C1_ER_IRQHandler ISR will clear it by calling the
 * I2C1_ErrorEventCallback function.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV5_REC} ................*/
static QState I2C1DevMgr_WaitFor_I2C_EV5_REC(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV5_REC} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV5_REC::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV5 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV5_REC::I2C_CHECK_EV::[EV5Happened?]} */
            if (I2C_CheckEvent(s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_MODE_SELECT)) {
                WRN_printf("Selecting slave I2C Device\n");

                /* Set the direction to transmit the address */
                I2C_SetDirection( me->iBus,  I2C_Direction_Transmitter);

                /* Send slave Address for write */
                I2C_Send7bitAddress(
                    s_I2C_Bus[me->iBus].i2c_bus,            /* This is always the bus used in this ISR */
                    s_I2C_Dev[me->iDevice].i2c_dev_addr,    /* Look up the current device address for this bus */
                    s_I2C_Bus[me->iBus].bTransDirection     /* Direction of data on this bus */
                );

                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV6_REC);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV5_REC::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV5_REC::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV5_REC);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV5_REC::I2C_CHECK_EV::[else]::[else]} */
                else {
                    WRN_printf("Expected timeout waiting for EV5 after bus recovery\n");
                    status_ = Q_TRAN(&I2C1DevMgr_StartI2CComm);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state selects I2C transmitter mode.
 * After a recovering the bus, the it needs to error out properly.  In order to
 * do this, a new communication has to be attempted.  This state continues after
 * previous state, because sometimes the error can happen a little later.
 * An error is expected and the I2C1_ER_IRQHandler ISR will clear it by
 * calling the I2C1_ErrorEventCallback function.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV6_REC} ................*/
static QState I2C1DevMgr_WaitFor_I2C_EV6_REC(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV6_REC} */
        case Q_ENTRY_SIG: {
            /* Post an event to check for EV5 event */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV6_REC::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if EV6 has happened.  If it has, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV6_REC::I2C_CHECK_EV::[EV6Happened?]} */
            if (I2C_CheckEvent( s_I2C_Bus[me->iBus].i2c_bus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED )) {
                status_ = Q_TRAN(&I2C1DevMgr_StartI2CComm);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV6_REC::I2C_CHECK_EV::[else]} */
            else {
                me->nI2CLoopTimeout--;                 /* Decrement counter */
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV6_REC::I2C_CHECK_EV::[else]::[Retriesleft?]} */
                if (me->nI2CLoopTimeout != 0) {
                    status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV6_REC);
                }
                /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitFor_I2C_EV6_REC::I2C_CHECK_EV::[else]::[else]} */
                else {
                    WRN_printf("Expected timeout waiting for I2C EV6 after bus recovery\n");
                    status_ = Q_TRAN(&I2C1DevMgr_StartI2CComm);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state initiates I2C communication by checking if I2C bus busy
 * flag is set.  If the flag is set, it attempts to recover the bus (see
 * WaitForBusRecovery state for details), otherwise, it continues.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::StartI2CComm} .......................*/
static QState I2C1DevMgr_StartI2CComm(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::StartI2CComm} */
        case Q_ENTRY_SIG: {
            /* Create event to check event and publish it */
            QEvt *qEvt = Q_NEW(QEvt, I2C_CHECK_EV_SIG);
            QF_PUBLISH((QEvt *)qEvt, AO_I2CMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::StartI2CComm::I2C_CHECK_EV} */
        case I2C_CHECK_EV_SIG: {
            /* Check if bus is busy.  If free, go on to the next state.  Otherwise,
             * try again until number of retries is out */
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::StartI2CComm::I2C_CHECK_EV::[BusFree?]} */
            if (RESET == I2C_GetFlagStatus( s_I2C_Bus[me->iBus].i2c_bus, I2C_FLAG_BUSY )) {
                DBG_printf("Bus free and ready\n");

                /* Reset the maximum number of times to poll the I2C bus for an event */
                me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
                status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV5);
            }
            /* ${AOs::I2C1DevMgr::SM::Active::Busy::StartI2CComm::I2C_CHECK_EV::[else]} */
            else {
                status_ = Q_TRAN(&I2C1DevMgr_TogglingSCL);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state waits for the bus to settle after being reconfigured to I2C.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusToSettle} .................*/
static QState I2C1DevMgr_WaitForBusToSettle(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusToSettle} */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->i2cRecoveryTimerEvt,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUS_RECOVERY_SEC )
            );

            /* Rearm the main I2C timer for a value that is enough for the current recovery
             * effort and enough to retry the operation that caused the problem in the first
             * place */
            QTimeEvt_rearm(
                &me->i2cTimerEvt,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_I2C_BUSY_SEC + LL_MAX_TIMEOUT_I2C_BUS_RECOVERY_SEC )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusToSettle} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm( &me->i2cRecoveryTimerEvt );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Busy::WaitForBusToSettle::I2C_RECOVERY_TIMEOUT} */
        case I2C_RECOVERY_TIMEOUT_SIG: {
            WRN_printf("Finished waiting for bus to settle after reset and intentional failure\n");

            /* Send START condition */
            WRN_printf("Generating I2C start after bus reset\n");
            I2C_GenerateSTART(s_I2C_Bus[me->iBus].i2c_bus, ENABLE);
            status_ = Q_TRAN(&I2C1DevMgr_WaitFor_I2C_EV5_REC);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief This state indicates that the I2C bus is currently idle and the
 * incoming msg can be handled.
 * This state is the default rest state of the state machine and can handle
 * various I2C requests.  Upon entry, it also checks the deferred queue to see
 * if any request events are waiting which were posted while I2C bus was busy.
 * if there are any waiting, it will read them out, which automatically posts
 * them and the state machine will go and handle them.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::I2C1DevMgr::SM::Active::Idle} .....................................*/
static QState I2C1DevMgr_Idle(I2C1DevMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::I2C1DevMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* recall the request from the private requestQueue */
            QActive_recall(
                (QActive *)me,
                &me->deferredEvtQueue
            );

            /* Clear out current operation */
            me->i2cCurrOperation = I2C_OP_NONE;

            DBG_printf("back in Idle\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Idle::I2C_READ_START} */
        case I2C_READ_START_SIG: {
            DBG_printf("Got I2C_READ_START\n");

            /* Set the current I2C operation */
            me->i2cCurrOperation = I2C_OP_READ;

            /* Store the device */
            me->iDevice = ((I2CEvt const *)e)->i2cDevice;

            /* Store device and operation settings from the event */
            s_I2C_Dev[me->iDevice].i2c_mem_addr = ((I2CEvt const *)e)->wAddr;
            s_I2C_Bus[me->iBus].nBytesExpected = ((I2CEvt const *)e)->wDataLen;
            s_I2C_Bus[me->iBus].nBytesCurrent = 0;
            s_I2C_Bus[me->iBus].nRxIndex = 0;

            /* Reset the maximum number of times to poll the I2C bus for an event */
            me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
            status_ = Q_TRAN(&I2C1DevMgr_StartI2CComm);
            break;
        }
        /* ${AOs::I2C1DevMgr::SM::Active::Idle::I2C_WRITE_START} */
        case I2C_WRITE_START_SIG: {
            DBG_printf("Got I2C_WRITE_START\n");

            /* Set the current I2C operation */
            me->i2cCurrOperation = I2C_OP_WRITE;

            /* Store the device */
            me->iDevice = ((I2CDataEvt const *)e)->i2cDevice;

            /* Store device and operation settings from the event */
            s_I2C_Dev[me->iDevice].i2c_mem_addr = ((I2CDataEvt const *)e)->wAddr;
            s_I2C_Bus[me->iBus].nBytesExpected = ((I2CDataEvt const *)e)->wDataLen;
            s_I2C_Bus[me->iBus].nBytesCurrent = 0;
            s_I2C_Bus[me->iBus].nTxIndex = 0;

            /* Copy data from the event to the buffer */
            MEMCPY(
                s_I2C_Bus[me->iBus].pTxBuffer,
                ((I2CDataEvt const *)e)->bufData,
                ((I2CDataEvt const *)e)->wDataLen
            );

            /* Reset the maximum number of times to poll the I2C bus for an event */
            me->nI2CLoopTimeout = MAX_I2C_TIMEOUT;
            status_ = Q_TRAN(&I2C1DevMgr_StartI2CComm);
            break;
        }
        default: {
            status_ = Q_SUPER(&I2C1DevMgr_Active);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupI2C
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/
