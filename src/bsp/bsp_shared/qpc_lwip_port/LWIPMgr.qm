<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <documentation>/**
 * LWIPMgr Active Object which.  This AO handles any ethernet work
 */</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="EthEvt" superclass="qpc::QEvt">
   <documentation>/**
 * \struct Event struct type for getting data from Eth driver to LWIPMgr.
 */</documentation>
   <attribute name="msg_src" type="MsgSrc" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Where the msg came from so it can be routed back to the sender. */</documentation>
   </attribute>
   <attribute name="msg_len" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of the msg buffer. */</documentation>
   </attribute>
   <attribute name="msg[MAX_MSG_LEN]" type="char" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data of the msg. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="LWIPMgr" superclass="qpc::QActive">
   <documentation>/**
 * \brief LWIPMgr &quot;class&quot;
 */</documentation>
   <attribute name="*netif" type="struct netif" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Pointer to LWIP netif struct. */</documentation>
   </attribute>
   <attribute name="*upcb" type="struct udp_pcb" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Pointer to LWIP udp pcb struct. */</documentation>
   </attribute>
   <attribute name="ip_addr" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; IP address in the native host byte order. */</documentation>
   </attribute>
   <attribute name="tcp_tmr;&#10;    #endif" type="#if LWIP_TCP&#10;    uint32_t " visibility="0x01" properties="0x00">
    <documentation>/**&lt; LWIP native TCP timer.  Only exists if LWIP_TCP is defined. */</documentation>
   </attribute>
   <attribute name="arp_tmr;&#10;    #endif" type="#if LWIP_ARP&#10;    uint32_t " visibility="0x01" properties="0x00">
    <documentation>/**&lt; LWIP native ARP timer.  Only exists if LWIP_ARP is defined. */</documentation>
   </attribute>
   <attribute name="dhcp_fine_tmr;&#10;    #endif" type="#if LWIP_DHCP&#10;    uint32_t " visibility="0x01" properties="0x00">
    <documentation>/**&lt; LWIP native DHCP fine timer.  Only exists if LWIP_DHCP is defined. */</documentation>
   </attribute>
   <attribute name="dhcp_coarse_tmr;&#10;    #endif" type="#if LWIP_DHCP&#10;    uint32_t " visibility="0x01" properties="0x00">
    <documentation>/**&lt; LWIP native DHCP coarse timer.  Only exists if LWIP_DHCP is defined. */</documentation>
   </attribute>
   <attribute name="auto_ip_tmr;&#10;    #endif" type="#if LWIP_AUTOIP&#10;    uint32_t " visibility="0x01" properties="0x00">
    <documentation>/**&lt; LWIP native AUTOIP coarse timer.  Only exists if LWIP_AUTOIP is defined. */</documentation>
   </attribute>
   <attribute name="tpcb_sys" type="struct tcp_pcb*" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Pointer to LWIP tcp pcb struct used to keep track of TCP connection to the
     system for commands and replies. */</documentation>
   </attribute>
   <attribute name="tpcb_log" type="struct tcp_pcb*" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Pointer to LWIP tcp pcb struct used to keep track of TCP connection to the
     system for logging. */</documentation>
   </attribute>
   <attribute name="logPort" type="uint16_t" visibility="0x01" properties="0x01">
    <documentation>/* Keeps track of what port is used by logging TCP connection */</documentation>
   </attribute>
   <attribute name="sysPort" type="uint16_t" visibility="0x01" properties="0x01">
    <documentation>/* Keeps track of what port is used by system TCP connection */</documentation>
   </attribute>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="es_log" type="struct echo_state*" visibility="0x01" properties="0x01">
    <documentation>/* Pointer to the log socket state that will be passed in to the TCP callback 
 * functions. */</documentation>
   </attribute>
   <attribute name="es_sys" type="struct echo_state*" visibility="0x01" properties="0x01">
    <documentation>/* Pointer to the log socket state that will be passed in to the TCP callback 
 * functions. */</documentation>
   </attribute>
   <attribute name="te_LWIP_SLOW_TICK" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Local timer for LWIP slow tick. */</documentation>
   </attribute>
   <attribute name="te_TcpSend" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Local timer for TCP send timeout. */</documentation>
   </attribute>
   <attribute name="isEthDbgEnabled" type="bool" visibility="0x01" properties="0x00"/>
   <statechart>
    <initial target="../1/6">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

uint8_t  macaddr[NETIF_MAX_HWADDR_LEN];

QS_OBJ_DICTIONARY(&amp;l_LWIPMgr);
QS_OBJ_DICTIONARY(&amp;l_LWIPMgr.te_LWIP_SLOW_TICK);

QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;LWIPMgr_initial);
QS_FUN_DICTIONARY(&amp;LWIPMgr_Active);
QS_FUN_DICTIONARY(&amp;udp_rx_handler);
QS_FUN_DICTIONARY(&amp;ETH_SendMsg_Handler);

QS_FILTER_SM_OBJ(0);                  /* Turn off all tracing for this SM */
QS_FILTER_AO_OBJ(0);                  /* Turn off all tracing for this AO */
QS_FILTER_TE_OBJ(0);           /* Turn off time event tracing for this AO */

/* TODO: temporary assignment of logging and system port numbers.  These
 * will eventually be assigned via BOOTP based on which board this is. */
LWIPMgr_sysPort = 1500;
LWIPMgr_logPort = 1501;

me-&gt;isEthDbgEnabled = true; // Enable debugging over ethernet by default.

/* Configure the hardware MAC address for the Ethernet Controller */

/*
 * Set up the MAC address and make sure it's not all FF values
 * TODO: This will evetually be read somewhere
 */

/* the MAC address must have been programmed! */
Q_ASSERT((STATIC_IPADDR0 != 0xFF) &amp;&amp;
        (STATIC_IPADDR1 != 0xFF) &amp;&amp;
        (STATIC_IPADDR2 != 0xFF) &amp;&amp;
        (STATIC_IPADDR3 != 0xFF));

macaddr[0] = DEF_MAC_ADDR0;
macaddr[1] = DEF_MAC_ADDR1;
macaddr[2] = DEF_MAC_ADDR2;
macaddr[3] = DEF_MAC_ADDR3;
macaddr[4] = DEF_MAC_ADDR4;
macaddr[5] = DEF_MAC_ADDR5;

DBG_printf(&quot;Static IP address: %d.%d.%d.%d\n&quot;,
      STATIC_IPADDR0, STATIC_IPADDR1, STATIC_IPADDR2, STATIC_IPADDR3);
DBG_printf(&quot;MAC address: %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n&quot;,
      macaddr[0], macaddr[1],macaddr[2],macaddr[3],macaddr[4], macaddr[5]);

me-&gt;ip_addr = 0xFFFFFFFF;               /* initialize to impossible value */
                                        /* initialize the Ethernet Driver */
me-&gt;netif = eth_driver_init((QActive *)me, macaddr);

/* Set up UDP related PCB */
me-&gt;upcb = udp_new();
udp_bind(me-&gt;upcb, IP_ADDR_ANY, 777);             /* use port 777 for UDP */
udp_recv(me-&gt;upcb, &amp;udp_rx_handler, me);

/* Set up TCP related PCB  for system connnection */
me-&gt;tpcb_sys = tcp_new();
if (me-&gt;tpcb_sys == NULL) {
   ERR_printf(&quot;Unable to allocate LWIP memory for TCP\n&quot;);
}
err_t err = tcp_bind(me-&gt;tpcb_sys, IP_ADDR_ANY, LWIPMgr_sysPort);
if (ERR_OK != err ) {
   ERR_printf(&quot;Unable to bind TCP to port %d\n&quot;, LWIPMgr_sysPort);
}

me-&gt;tpcb_sys = tcp_listen(me-&gt;tpcb_sys);
tcp_accept(me-&gt;tpcb_sys, LWIP_tcpAccept);

/* Set up TCP related PCB  for log/dbg connnection */
me-&gt;tpcb_log = tcp_new();
if (me-&gt;tpcb_log == NULL) {
   ERR_printf(&quot;Unable to allocate LWIP memory for TCP_LOG socket\n&quot;);
}
err = tcp_bind(me-&gt;tpcb_log, IP_ADDR_ANY, LWIPMgr_logPort);
if (ERR_OK != err ) {
   ERR_printf(&quot;Unable to bind TCP to port %d\n&quot;, LWIPMgr_logPort);
}

me-&gt;tpcb_log = tcp_listen(me-&gt;tpcb_log);

LWIPMgr_es_log = NULL;
tcp_accept(me-&gt;tpcb_log, LWIP_tcpAccept);

/* Signal subscriptions */
QActive_subscribe((QActive *)me, ETH_UDP_SEND_SIG);
QActive_subscribe((QActive *)me, ETH_LOG_TCP_SEND_SIG);
QActive_subscribe((QActive *)me, ETH_SYS_TCP_SEND_SIG);
QActive_subscribe((QActive *)me, DBG_LOG_SIG);
QActive_subscribe((QActive *)me, DBG_MENU_SIG);
QActive_subscribe((QActive *)me, TCP_DONE_SIG);
QActive_subscribe((QActive *)me, ETH_DBG_TOGGLE_SIG);
</action>
     <initial_glyph conn="1,2,4,3,8,6">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>QTimeEvt_postEvery(
    &amp;me-&gt;te_LWIP_SLOW_TICK,
    (QActive *)me,
    (LWIP_SLOW_TICK_MS * BSP_TICKS_PER_SEC) / 1000
);

/* Post all the other timers and disarm them right away so it can be
 * rearmed at any point without worrying asserts. */
QTimeEvt_postIn(
    &amp;me-&gt;te_TcpSend,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_TCP_SEND_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;te_TcpSend);</entry>
     <exit>QTimeEvt_disarm(&amp;me-&gt;te_LWIP_SLOW_TICK);</exit>
     <tran trig="ETH_UDP_SEND">
      <action>/* Event posted that will include (inside it) a msg to send */
if (me-&gt;upcb-&gt;remote_port != (uint16_t)0) {
    struct pbuf *p = pbuf_new(
        (u8_t *)((EthEvt const *)e)-&gt;msg,
        ((EthEvt const *)e)-&gt;msg_len
    );
    if (p != (struct pbuf *)0) {
        udp_send(me-&gt;upcb, p);
        pbuf_free(p);                   /* don't leak the pbuf! */
    }
}</action>
      <tran_glyph conn="3,74,3,-1,15">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="LWIP_RX_READY">
      <action>eth_driver_read();</action>
      <tran_glyph conn="3,62,3,-1,15">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="LWIP_TX_READY">
      <action>eth_driver_write();</action>
      <tran_glyph conn="3,65,3,-1,15">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="LWIP_SLOW_TICK">
      <action>/* has IP address changed? */
if (me-&gt;ip_addr != me-&gt;netif-&gt;ip_addr.addr) {
    uint32_t ip_net;    /* IP address in the network byte order */
    me-&gt;ip_addr = me-&gt;netif-&gt;ip_addr.addr; /* save the IP addr. */
    ip_net  = ntohl(me-&gt;ip_addr);
}

#if LWIP_TCP
me-&gt;tcp_tmr += LWIP_SLOW_TICK_MS;
if (me-&gt;tcp_tmr &gt;= TCP_TMR_INTERVAL) {
    me-&gt;tcp_tmr = 0;
    tcp_tmr();
}
#endif

#if LWIP_ARP
me-&gt;arp_tmr += LWIP_SLOW_TICK_MS;
if (me-&gt;arp_tmr &gt;= ARP_TMR_INTERVAL) {
    me-&gt;arp_tmr = 0;
    etharp_tmr();
}
#endif

#if LWIP_DHCP
me-&gt;dhcp_fine_tmr += LWIP_SLOW_TICK_MS;
if (me-&gt;dhcp_fine_tmr &gt;= DHCP_FINE_TIMER_MSECS) {
    me-&gt;dhcp_fine_tmr = 0;
    dhcp_fine_tmr();
    if (me-&gt;netif-&gt;dhcp-&gt;state == DHCP_BOUND) {
       DBG_printf(&quot;DHCP BOUND to addr: %d.%d.%d.%d\n&quot;,
             ip4_addr1_16(&amp;me-&gt;netif-&gt;dhcp-&gt;offered_ip_addr),
             ip4_addr2_16(&amp;me-&gt;netif-&gt;dhcp-&gt;offered_ip_addr),
             ip4_addr3_16(&amp;me-&gt;netif-&gt;dhcp-&gt;offered_ip_addr),
             ip4_addr4_16(&amp;me-&gt;netif-&gt;dhcp-&gt;offered_ip_addr)
       );
    } else {
       WRN_printf(&quot;DHCP NOT BOUND!\n&quot;);
    }
}
me-&gt;dhcp_coarse_tmr += LWIP_SLOW_TICK_MS;
if (me-&gt;dhcp_coarse_tmr &gt;= DHCP_COARSE_TIMER_MSECS) {
    me-&gt;dhcp_coarse_tmr = 0;
    dhcp_coarse_tmr();
}
#endif

#if LWIP_AUTOIP
me-&gt;auto_ip_tmr += LWIP_SLOW_TICK_MS;
if (me-&gt;auto_ip_tmr &gt;= AUTOIP_TMR_INTERVAL) {
    me-&gt;auto_ip_tmr = 0;
    autoip_tmr();
}
#endif</action>
      <tran_glyph conn="3,68,3,-1,15">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <tran trig="LWIP_RX_OVERRUN">
      <action>LINK_STATS_INC(link.err);</action>
      <tran_glyph conn="3,71,3,-1,15">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <tran trig="ETH_DBG_TOGGLE">
      <action>me-&gt;isEthDbgEnabled = !(me-&gt;isEthDbgEnabled);</action>
      <tran_glyph conn="3,77,3,-1,15">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <state name="Idle">
      <documentation>/**
 * @brief This state is for handling TCP send events.
 * When a TCP SEND event is received, the state will route it to the appropriate
 * signal handler who will then attempt to buffer it in the TCP LWIP queue.  If
 * there's no space available, the event is deferred and the SM goes to the
 * Sending state.  If the data was successfully buffered in the TCP LWIP queue,
 * the SM stays in the Idle state.
 *
 * @note: data in the TCP LWIP queue is sent out when the LWIP coarse timer
 * expires.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* recall the request from the private requestQueue */
QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);</entry>
      <exit>/* Failed to send data, probably because out of pbufs.  Defer the event
 * (if possible) and it will try again after getting back from &quot;Sending&quot;
 * state. */
if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
    /* defer the request - this event will be handled
     * when the state machine goes back to Idle state */
    QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
} else {
    /* notify the request sender that the request was ignored.. */
    err_slow_printf(&quot;Unable to defer an ETH event&quot;);
}</exit>
      <tran trig="DBG_MENU">
       <action>/************************************************************/
/* WARNING: Do not use any fast logging functions here.  In
 * fact, avoid using ANY logging here since it could cause an
 * infinite loop. */
/************************************************************/</action>
       <choice>
        <guard brief="else"/>
        <action>DBG_printf(&quot;Conn NULL\n&quot;);</action>
        <choice_glyph conn="26,14,4,-1,4">
         <action box="1,2,10,2"/>
        </choice_glyph>
       </choice>
       <choice>
        <guard brief="ConnExists?">NULL != LWIPMgr_es_log</guard>
        <action>struct pbuf *p = pbuf_new(
    (u8_t *)((LrgDataEvt const *)e)-&gt;dataBuf,
    ((LrgDataEvt const *)e)-&gt;dataLen
);</action>
        <choice target="../../../../7">
         <guard>else</guard>
         <action>WRN_printf(&quot;MEM unavailable, trying again in a bit...\n&quot;);</action>
         <choice_glyph conn="59,14,4,3,6,40">
          <action box="0,4,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="Mem Avail?">p != (struct pbuf *)0</guard>
         <action>LWIPMgr_es_log-&gt;p = p;                         // Attach pbuf to the socket state
//dbg_slow_printf(&quot;c tcpSend, me-&gt;tpcb: %x, LWIPMgr_es_log-&gt;pcb: %x\n&quot;, (uint32_t) me-&gt;tpcb_log, (uint32_t) LWIPMgr_es_log-&gt;pcb);
tcp_sent(LWIPMgr_es_log-&gt;pcb, LWIP_tcpSent);   // Set callback
bool dataSent = LWIP_tcpSend(
    LWIPMgr_es_log-&gt;pcb,
    LWIPMgr_es_log
);                                             // Queue data for sending
pbuf_free(p);                                  // don't leak the pbuf!</action>
         <choice target="../../../../../7">
          <guard brief="Data not sent?">false == dataSent</guard>
          <action>pbuf_free(p);                                  // don't leak the pbuf!</action>
          <choice_glyph conn="73,14,5,3,26">
           <action box="1,-2,14,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard>else</guard>
          <choice_glyph conn="73,14,4,-1,4">
           <action box="0,2,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="59,14,5,-1,14">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <choice_glyph conn="26,14,5,-1,33">
         <action box="1,0,12,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="7,14,3,-1,19">
        <action box="0,-2,11,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DBG_LOG, ETH_LOG_TCP_SEND">
       <action>/************************************************************/
/* WARNING: Do not use any fast logging functions here.  In
 * fact, avoid using ANY logging here since it could cause an
 * infinite loop. */
/************************************************************/</action>
       <choice>
        <guard brief="EthDbgEnabled?">true == me-&gt;isEthDbgEnabled</guard>
        <choice>
         <guard brief="ConnExists?">NULL != LWIPMgr_es_log</guard>
         <action>struct pbuf *p = pbuf_new(
    (u8_t *)((LrgDataEvt const *)e)-&gt;dataBuf,
    ((LrgDataEvt const *)e)-&gt;dataLen
);</action>
         <choice target="../../../../../7">
          <guard>else</guard>
          <action>WRN_printf(&quot;MEM unavailable, trying again in a bit...\n&quot;);</action>
          <choice_glyph conn="59,23,4,3,6,40">
           <action box="0,4,10,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="Mem Avail?">p != (struct pbuf *)0</guard>
          <action>LWIPMgr_es_log-&gt;p = p;                         // Attach pbuf to the socket state
//dbg_slow_printf(&quot;c tcpSend, me-&gt;tpcb: %x, LWIPMgr_es_log-&gt;pcb: %x\n&quot;, (uint32_t) me-&gt;tpcb_log, (uint32_t) LWIPMgr_es_log-&gt;pcb);
tcp_sent(LWIPMgr_es_log-&gt;pcb, LWIP_tcpSent);   // Set callback
bool dataSent = LWIP_tcpSend(
    LWIPMgr_es_log-&gt;pcb,
    LWIPMgr_es_log
);                                             // Queue data for sending
pbuf_free(p);                                  // don't leak the pbuf!</action>
          <choice target="../../../../../../7">
           <guard brief="Data not sent?">false == dataSent</guard>
           <action>pbuf_free(p);                                  // don't leak the pbuf!</action>
           <choice_glyph conn="73,23,5,3,26">
            <action box="1,-2,14,2"/>
           </choice_glyph>
          </choice>
          <choice>
           <guard>else</guard>
           <choice_glyph conn="73,23,4,-1,4">
            <action box="0,2,6,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="59,23,5,-1,14">
           <action box="1,-2,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="45,23,5,-1,14">
          <action box="1,-2,12,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="else"/>
         <choice_glyph conn="45,23,4,-1,4">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice_glyph conn="26,23,5,-1,19">
         <action box="1,-2,14,2"/>
        </choice_glyph>
       </choice>
       <choice>
        <guard>else</guard>
        <choice_glyph conn="26,23,4,-1,4">
         <action box="0,2,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="7,23,3,-1,19">
        <action box="0,-4,18,4"/>
       </tran_glyph>
      </tran>
      <tran trig="ETH_SYS_TCP_SEND">
       <action>

/* Event posted that will include (inside it) a msg to send */
if (me-&gt;upcb-&gt;remote_port != (uint16_t)0) {
    struct pbuf *p = pbuf_new(
        (u8_t *)((EthEvt const *)e)-&gt;msg,
        ((EthEvt const *)e)-&gt;msg_len
    );
    if (p != (struct pbuf *)0) {
        udp_send(me-&gt;upcb, p);
        pbuf_free(p);                   /* don't leak the pbuf! */
    }
}</action>
       <choice>
        <guard brief="ConnExists?">NULL != LWIPMgr_es_sys</guard>
        <action>struct pbuf *p = pbuf_new(
    (u8_t *)((LrgDataEvt const *)e)-&gt;dataBuf,
    ((LrgDataEvt const *)e)-&gt;dataLen
);</action>
        <choice target="../../../../7">
         <guard>else</guard>
         <action>WRN_printf(&quot;MEM unavailable, trying again in a bit...\n&quot;);</action>
         <choice_glyph conn="59,35,4,3,6,40">
          <action box="0,4,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="Mem Avail?">p != (struct pbuf *)0</guard>
         <action>LWIPMgr_es_sys-&gt;p = p;                         // Attach pbuf to the socket state
//dbg_slow_printf(&quot;c tcpSend, me-&gt;tpcb: %x, LWIPMgr_es_log-&gt;pcb: %x\n&quot;, (uint32_t) me-&gt;tpcb_log, (uint32_t) LWIPMgr_es_log-&gt;pcb);
tcp_sent(LWIPMgr_es_sys-&gt;pcb, LWIP_tcpSent);   // Set callback
bool dataSent = LWIP_tcpSend(
    LWIPMgr_es_sys-&gt;pcb,
    LWIPMgr_es_sys
);                                             // Queue data for sending
pbuf_free(p);                                  // don't leak the pbuf!</action>
         <choice target="../../../../../7">
          <guard brief="Data not sent?">false == dataSent</guard>
          <action>pbuf_free(p);                                  // don't leak the pbuf!</action>
          <choice_glyph conn="73,35,5,3,26">
           <action box="1,-2,14,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard>else</guard>
          <choice_glyph conn="73,35,4,-1,4">
           <action box="0,2,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="59,35,5,-1,14">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <choice_glyph conn="45,35,5,-1,14">
         <action box="1,-2,12,2"/>
        </choice_glyph>
       </choice>
       <choice>
        <guard brief="else"/>
        <action>ERR_printf(&quot;Attempting to send data over system ethernet port but no connection exists.  Something is probably very wrong!\n&quot;);</action>
        <choice_glyph conn="45,35,4,-1,4">
         <action box="0,2,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="7,35,3,-1,38">
        <action box="0,-2,17,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="7,6,76,48">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="Sending">
      <documentation>/**
 * @brief This state is for handling TCP send events while the TCP LWIP queue is
 * full.
 * After the TCP LWIP queue fills up, the SM goes to this state where any TCP
 * SEND events will get deferred.  The SM leaves this state after receiving a 
 *
 * @note: data in the TCP LWIP queue is sent out when the LWIP coarse timer
 * expires.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Arm the timer so if the connection is broken for some reason, we can get back
 * to idle state */
QTimeEvt_rearm(
    &amp;me-&gt;te_TcpSend,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_TCP_SEND_SEC )
);</entry>
      <exit>QTimeEvt_disarm( &amp;me-&gt;te_TcpSend );</exit>
      <tran trig="TCP_DONE" target="../../6">
       <tran_glyph conn="99,50,3,1,-16">
        <action box="-15,-2,15,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DBG_LOG, DBG_MENU, ETH_LOG_TCP_SEND">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
} else {
   /* notify the request sender that the request was ignored.. */
   err_slow_printf(&quot;Unable to defer an ETH event&quot;);
}</action>
       <tran_glyph conn="99,45,3,-1,14">
        <action box="0,-6,16,6"/>
       </tran_glyph>
      </tran>
      <tran trig="TCP_TIMEOUT" target="../../6">
       <action>ERR_printf(&quot;Timed out waiting for TCP acks.  Returning to Idle.  Data loss likely\n&quot;);</action>
       <tran_glyph conn="99,53,3,1,-16">
        <action box="-15,-2,13,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="99,6,19,48">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,2,125,78">
      <entry box="1,2,5,2"/>
      <exit box="1,4,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="129,90"/>
   </statechart>
  </class>
  <attribute name="AO_LWIPMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="LWIPMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for LWIP &quot;class&quot;.
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */</documentation>
   <code>LWIPMgr *me = &amp;l_LWIPMgr;

QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;LWIPMgr_initial);
QTimeEvt_ctor(&amp;me-&gt;te_LWIP_SLOW_TICK, LWIP_SLOW_TICK_SIG);
QTimeEvt_ctor(&amp;me-&gt;te_TcpSend, TCP_TIMEOUT_SIG);

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);</code>
  </operation>
  <operation name="LWIP_tcpPoll" type="err_t" visibility="0x02" properties="0x00">
   <documentation>/**
 * @brief: A callback function that handles the start of a RECV on a TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */</documentation>
   <parameter name="arg" type="void *"/>
   <parameter name="tpcb" type="struct tcp_pcb *"/>
   <code>err_t ret_err;
struct echo_state *es;
es = (struct echo_state *)arg;
if (es != NULL) {
    if (es-&gt;p != NULL) {
        /* there is a remaining pbuf (chain)  */
        tcp_sent(tpcb, LWIP_tcpSent);
        LWIP_tcpSend(tpcb, es);
    } else {
        /* no remaining pbuf (chain)  */
        if(es-&gt;state == ES_CLOSING) {
            LWIP_tcpClose(tpcb, es);
        }
    }
    ret_err = ERR_OK;
} else {
    /* nothing to be done */
    tcp_abort(tpcb);
    ret_err = ERR_ABRT;
}
return ret_err;</code>
  </operation>
  <operation name="LWIP_tcpSent" type="err_t" visibility="0x02" properties="0x00">
   <documentation>/**
 * @brief: A callback function that handles the start of a RECV on a
 * TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] len: uint16_t length of data sent.
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */</documentation>
   <parameter name="arg" type="void *"/>
   <parameter name="tpcb" type="struct tcp_pcb *"/>
   <parameter name="len" type="uint16_t"/>
   <code>struct echo_state *es;
LWIP_UNUSED_ARG(len);
es = (struct echo_state *)arg;
es-&gt;retries = 0;
if(es-&gt;p != NULL) {
    /* still got pbufs to send */
    tcp_sent(tpcb, LWIP_tcpSent);
    LWIP_tcpSend(tpcb, es);
} else {
    /* no more pbufs to send */
    if(es-&gt;state == ES_CLOSING) {
        LWIP_tcpClose(tpcb, es);
    }
    QEvt *qEvt = Q_NEW( QEvt, TCP_DONE_SIG);
    QF_PUBLISH(qEvt, AO_LWIPMgr);
}
return ERR_OK;</code>
  </operation>
  <operation name="LWIP_tcpSend" type="bool" visibility="0x02" properties="0x00">
   <documentation>/**
 * @brief: A callback function that handles the actual sending of data
 * on a TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in|out] *es: echo_state struct to keep track of the socket state.
 *
 * @return None
 */</documentation>
   <parameter name="tpcb" type="struct tcp_pcb *"/>
   <parameter name="es" type="struct echo_state *"/>
   <code>struct pbuf *ptr;
err_t wr_err = ERR_OK;
bool status = false;

while ((wr_err == ERR_OK) &amp;&amp; (es-&gt;p != NULL) &amp;&amp; (es-&gt;p-&gt;len &lt;= tcp_sndbuf(tpcb))) {
    ptr = es-&gt;p;
    /* enqueue data for transmission */
    wr_err = tcp_write(tpcb, ptr-&gt;payload, ptr-&gt;len, 1);
    if (wr_err == ERR_OK) {
        status = true;
        uint16_t plen;
        uint8_t freed;
        plen = ptr-&gt;len;

        /* continue with next pbuf in chain (if any) */
        es-&gt;p = ptr-&gt;next;
        if(es-&gt;p != NULL) {
            /* new reference! */
            pbuf_ref(es-&gt;p);
        }
        /* chop first pbuf from chain */
        do {
            /* try hard to free pbuf */
            freed = pbuf_free(ptr);
        } while(freed == 0);

        /* we can read more data now */
        tcp_recved(tpcb, plen);
    } else if(wr_err == ERR_MEM) {
        /* we are low on memory, try later / harder, defer to poll */
        es-&gt;p = ptr;
        WRN_printf(&quot;Running low on mem in LWIP, polling later\n&quot;);
        status = false;
    } else {
        /* other problem ?? */
        WRN_printf(&quot;Some unknown problem occurred\n&quot;);
        status = false;
    }
}

return( status );</code>
  </operation>
  <operation name="LWIP_tcpError" type="void" visibility="0x02" properties="0x00">
   <documentation>/**
 * @brief: A callback function that handles the errors on a TCP socket.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return None
 */</documentation>
   <parameter name="arg" type="void *"/>
   <parameter name="err" type="err_t"/>
   <code>struct echo_state *es;
LWIP_UNUSED_ARG(err);
es = (struct echo_state *)arg;
if (es != NULL) {
    if ( LWIPMgr_logPort == es-&gt;pcb-&gt;local_port ) {
        LWIPMgr_es_log = NULL;
        LOG_printf(&quot;Log/Dbg TCP Connection on port %d closed\n&quot;, es-&gt;pcb-&gt;local_port);
    } else if ( LWIPMgr_sysPort == es-&gt;pcb-&gt;local_port ) {
        LWIPMgr_es_log = NULL;
        LOG_printf(&quot;System TCP Connection on port %d closed\n&quot;, es-&gt;pcb-&gt;local_port);
    } else {
        WRN_printf(
            &quot;Attempting to close an unknown socket on port %d\n&quot;,
            es-&gt;pcb-&gt;local_port
        );
    }
    mem_free(es);
}
ERR_printf(&quot;Handling error, freeing memory\n&quot;);</code>
  </operation>
  <operation name="LWIP_tcpClose" type="void" visibility="0x02" properties="0x00">
   <documentation>/**
 * @brief: A callback function that handles the closing the TCP socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in|out] *tpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in|out] *es: echo_state struct to keep track of the socket state.
 *
 * @return None
 */</documentation>
   <parameter name="tpcb" type="struct tcp_pcb *"/>
   <parameter name="es" type="struct echo_state *"/>
   <code>tcp_arg(tpcb, NULL);
tcp_sent(tpcb, NULL);
tcp_recv(tpcb, NULL);
tcp_err(tpcb, NULL);
tcp_poll(tpcb, NULL, 0);

if (es != NULL) {
    if ( LWIPMgr_logPort == tpcb-&gt;local_port ) {
        LWIPMgr_es_log = NULL;
        LOG_printf(&quot;Log/Dbg TCP Connection on port %d closed\n&quot;, tpcb-&gt;local_port);
    } else if ( LWIPMgr_sysPort == tpcb-&gt;local_port ) {
        LWIPMgr_es_log = NULL;
        LOG_printf(&quot;System TCP Connection on port %d closed\n&quot;, tpcb-&gt;local_port);
    } else {
        WRN_printf(
            &quot;Attempting to close an unknown socket on port %d\n&quot;,
            tpcb-&gt;local_port
        );
    }
    mem_free(es);
}

tcp_close(tpcb);</code>
  </operation>
  <operation name="LWIP_tcpRecv" type="err_t" visibility="0x02" properties="0x00">
   <documentation>/**
 * @brief: A callback function that handles the start of a RECV on the
 * TCP sockets.
 * This function is passed in as a callback to tcp_recv().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] *newpcb: struct tcp_pcb pointer to the pcb that is handling the
 * context for this connection.
 * @param [in] *p: struct pbuf pointer to the LWIP pbuf that actually
 * contains the data received.
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */</documentation>
   <parameter name="arg" type="void *"/>
   <parameter name="tpcb" type="struct tcp_pcb *"/>
   <parameter name="p" type="struct pbuf *"/>
   <parameter name="err" type="err_t"/>
   <code>struct echo_state *es;
err_t ret_err;

LWIP_ASSERT(&quot;arg != NULL&quot;,arg != NULL);
es = (struct echo_state *)arg;
if (p == NULL) {
    /* remote host closed connection */
    es-&gt;state = ES_CLOSING;
    if(es-&gt;p == NULL) {
        LOG_printf(&quot;Closing connection\n&quot;);
        /* we're done sending, close it */
        LWIP_tcpClose(tpcb, es);
    } else {
        /* we're not done yet */
        tcp_sent(tpcb, LWIP_tcpSent);
        LWIP_tcpSend(tpcb, es);
    }
    ret_err = ERR_OK;

} else if(err != ERR_OK) {
    /* cleanup, for unkown reason */
    if (p != NULL) {
        es-&gt;p = NULL;
        pbuf_free(p);
    }
    ret_err = err;
    ERR_printf(&quot;Unknown error\n&quot;);
} else if(es-&gt;state == ES_ACCEPTED) {
    /* first data chunk in p-&gt;payload */
    es-&gt;state = ES_RECEIVED;
    /* store reference to incoming pbuf (chain) */
    es-&gt;p = p;

    if ( LWIPMgr_logPort == tpcb-&gt;local_port ) {
        /* This eth port can only receive menu commands */
        MenuEvt *menuEvt = Q_NEW( MenuEvt, DBG_MENU_REQ_SIG );

        /* 2. Fill the msg payload with payload (the actual received msg)*/
        MEMCPY(
              menuEvt-&gt;buffer,
              p-&gt;payload,
              (p-&gt;tot_len)-1
        );
        menuEvt-&gt;bufferLen = (p-&gt;tot_len)-1;
        menuEvt-&gt;msgSrc = ETH_PORT_LOG;

        /* 3. Publish the newly created event to current AO */
        QF_PUBLISH( (QEvent *)menuEvt, AO_LWIPMgr );

    } else if ( LWIPMgr_sysPort == tpcb-&gt;local_port ) {
        LOG_printf(
            &quot;Received data on SYS port %d.\n&quot;,
            tpcb-&gt;local_port
        );
        EthEvt *ethEvt = Q_NEW(EthEvt, CPLR_ETH_SYS_TEST_SIG);

        /* Fill the msg payload with payload (the actual received msg)*/
        ethEvt-&gt;msg_len = (p-&gt;tot_len)-1;
        MEMCPY(
              ethEvt-&gt;msg,
              p-&gt;payload,
              ethEvt-&gt;msg_len
        );
        ethEvt-&gt;msg_src = ETH_PORT_SYS;

        /* Post directly to the &quot;raw&quot; queue for FreeRTOS task to read */
        QEQueue_postFIFO(&amp;CPLR_evtQueue, (QEvt *)ethEvt);
    } else {
        LOG_printf(
            &quot;Received data on unknown port %d.  Discarding.\n&quot;,
            tpcb-&gt;local_port
        );
    }

    /* Free the pbuf */
    tcp_recved(tpcb, p-&gt;tot_len);
    es-&gt;p = NULL;
    pbuf_free(p);
    ret_err = ERR_OK;
} else if (es-&gt;state == ES_RECEIVED) {
    /* read some more data */
    if(es-&gt;p == NULL) {
        es-&gt;p = p;

        if ( LWIPMgr_logPort == tpcb-&gt;local_port ) {
            /* This eth port can only receive menu commands */
            MenuEvt *menuEvt = Q_NEW( MenuEvt, DBG_MENU_REQ_SIG );

            /* 2. Fill the msg payload with payload (the actual received msg)*/
            MEMCPY(
                  menuEvt-&gt;buffer,
                  p-&gt;payload,
                  (p-&gt;tot_len)-1
            );
            menuEvt-&gt;bufferLen = (p-&gt;tot_len)-1;
            menuEvt-&gt;msgSrc = ETH_PORT_LOG;

            /* 3. Publish the newly created event to current AO */
            QF_PUBLISH( (QEvent *)menuEvt, AO_LWIPMgr );

        } else if ( LWIPMgr_sysPort == tpcb-&gt;local_port ) {
            DBG_printf(
                &quot;Received data on SYS port %d.\n&quot;,
                tpcb-&gt;local_port
            );
            EthEvt *ethEvt = Q_NEW(EthEvt, CPLR_ETH_SYS_TEST_SIG);

            /* Fill the msg payload with payload (the actual received msg)*/
            ethEvt-&gt;msg_len = (p-&gt;tot_len)-1;
            MEMCPY(
                  ethEvt-&gt;msg,
                  p-&gt;payload,
                  ethEvt-&gt;msg_len
            );
            ethEvt-&gt;msg_src = ETH_PORT_SYS;

            /* Post directly to the &quot;raw&quot; queue for FreeRTOS task to read */
            QEQueue_postFIFO(&amp;CPLR_evtQueue, (QEvt *)ethEvt);
        } else {
            LOG_printf(
                &quot;Received data on unknown port %d.  Discarding.\n&quot;,
                tpcb-&gt;local_port
            );
        }

        /* Free the pbuf */
        tcp_recved(tpcb, p-&gt;tot_len);
        es-&gt;p = NULL;
        pbuf_free(p);
        ret_err = ERR_OK;
    } else {
        struct pbuf *ptr;
         /* chain pbufs to the end of what we recv'ed previously  */
        ptr = es-&gt;p;
        pbuf_chain(ptr,p);
    }
    ret_err = ERR_OK;
} else if(es-&gt;state == ES_CLOSING) {
    /* odd case, remote side closing twice, trash data */
    tcp_recved(tpcb, p-&gt;tot_len);
    es-&gt;p = NULL;
    pbuf_free(p);
    ret_err = ERR_OK;
} else {
    /* unkown es-&gt;state, trash data  */
    tcp_recved(tpcb, p-&gt;tot_len);
    es-&gt;p = NULL;
    pbuf_free(p);
    ret_err = ERR_OK;
}
return ret_err;</code>
  </operation>
  <operation name="LWIP_tcpAccept" type="err_t" visibility="0x02" properties="0x00">
   <documentation>/**
 * @brief: A callback function that handles acceptance of a connection
 * on a TCP debug/logging socket.
 * This function is passed in as a callback to tcp_accept().
 *
 * @param [in] *arg: void pointer to an argument list (unused)
 * @param [in] *newpcb: struct tcp_pcb pointer to the pcb that is handling the 
 * context for this connection.
 * @param [in] err: err_t passed in from the caller. (unused)
 *
 * @return err: err_t indicating error that may have occurred.
 *   @arg ERR_OK: no error
 *   @arg ERR_MEM: memory allocation error
 */</documentation>
   <parameter name="arg" type="void *"/>
   <parameter name="newpcb" type="struct tcp_pcb *"/>
   <parameter name="err&#10;    " type="err_t"/>
   <code>err_t ret_err;
struct echo_state *es;

LWIP_UNUSED_ARG(arg);
LWIP_UNUSED_ARG(err);

if ( LWIPMgr_logPort == newpcb-&gt;local_port ) {
    if ( NULL != LWIPMgr_es_log ) {
        /* A connection on the logging port exists already. */
        ret_err = ERR_USE;
        WRN_printf(&quot;A connection on the logging port %d exists already.\n&quot;, newpcb-&gt;local_port );
        return ret_err;
   }
} else if ( LWIPMgr_sysPort == newpcb-&gt;local_port ) {
    if ( NULL != LWIPMgr_es_sys ) {
        /* A connection on the system port exists already. */
        ret_err = ERR_USE;
        WRN_printf(&quot;A connection on the logging port %d exists already.\n&quot;, newpcb-&gt;local_port );
        return ret_err;
   }
} else {
    ERR_printf(&quot;Unknown port number %d\n&quot;, newpcb-&gt;local_port );
    ret_err = ERR_VAL;
    return ret_err;
}

/* commonly observed practice to call tcp_setprio(), why? */
tcp_setprio(newpcb, TCP_PRIO_MIN);

es = (struct echo_state *)mem_malloc(sizeof(struct echo_state));
if ( es != NULL ) {
    es-&gt;state = ES_ACCEPTED;
    es-&gt;pcb = newpcb;
    es-&gt;retries = 0;
    es-&gt;p = NULL;
    ret_err = ERR_OK;

    /* pass newly allocated es to our callbacks */
    tcp_arg(newpcb, es);
    tcp_recv(newpcb, LWIP_tcpRecv);
    tcp_err(newpcb, LWIP_tcpError);
    tcp_poll(newpcb, LWIP_tcpPoll, 0);

    if ( LWIPMgr_logPort == newpcb-&gt;local_port ) {
        LWIPMgr_es_log = es; /* Tell the opaque pointer about this new structure. */
        LOG_printf(&quot;New connection accepted on log/debug port %d\n&quot;, newpcb-&gt;local_port);
    } else if ( LWIPMgr_sysPort == newpcb-&gt;local_port ) {
        LWIPMgr_es_sys = es; /* Tell the opaque pointer about this new structure. */
        LOG_printf(&quot;New connection accepted on system port %d\n&quot;, newpcb-&gt;local_port);
    } else {
        ERR_printf(&quot;Unknown port number %d\n&quot;, newpcb-&gt;local_port );
        ret_err = ERR_VAL;
        return ret_err;
    }
} else {
    ret_err = ERR_MEM;
    ERR_printf(&quot;Error allocating LWIP mem for echo state\n&quot;);
}
return ret_err;</code>
  </operation>
 </package>
 <directory name=".">
  <file name="LWIPMgr_gen.c">
   <text>/**
 * @file     LWIPMgr.c
 * @brief This file contains the definitions of the LWIPMgr Active Object and
 * its state machines.
 *
 * LWIPMgr is responsible for handling all communications with the ethernet
 * driver.  It is the only state machine that has exclusive access to the
 * ethernet hardware and facilitates sharing by allowing other state machines
 * to publish events to the QPC RTOS.  QPC queues the events to be handled by
 * the LWIPMgr state machine in the FIFO order.
 *
 * Note: If editing this file, please make sure to update the LWIPMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date       06/09/2014
 * @author     Harry Rostovtsev
 * @email      harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupLWIP_QPC_Eth
 * @{
 */

#define LWIP_ALLOWED     /* This must be set before the include to allow LWIP */

/* Includes ------------------------------------------------------------------*/
#include &quot;LWIPMgr.h&quot;
#include &quot;lwip.h&quot;                                               /* lwIP stack */
#include &quot;bsp_defs.h&quot;
#include &quot;DbgMgr.h&quot;                                           /* For MenuEvt */
#include &quot;cplr.h&quot;  /* for access to the raw queue used to talk to CPLR tastk */

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE                  /* For QSPY to know the name of this file */
Q_ASSERT_COMPILE(MAX_SHARED_SIG &lt; DEV_DRIVER_SIG);/* app signal overlap check */
DBG_DEFINE_THIS_MODULE( DBG_MODL_ETH ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
/**
 * \enum TCP socket states.
 */
enum echo_states {
    ES_NONE = 0,                                        /**&lt; Default no state */
    ES_ACCEPTED,                                     /**&lt; Connection accepted */
    ES_RECEIVED,                             /**&lt; Data received on the socket */
    ES_CLOSING                                        /**&lt; Connection closing */
};

/**
 * \struct Keep track of TCP socket states.
 */
struct echo_state {
    uint8_t state;                              /**&lt; echo_states socket state */
    uint8_t retries;                         /**&lt; Number of retries attempted */
    struct tcp_pcb *pcb;                              /**&lt; Connection context */
    struct pbuf *p;                              /**&lt; pbuf (chain) to recycle */
};

$declare(AOs::LWIPMgr)

/* Private defines -----------------------------------------------------------*/
#define LWIP_SLOW_TICK_MS       TCP_TMR_INTERVAL

/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static LWIPMgr l_LWIPMgr;       /* the single instance of the active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_LWIPMgr = (QActive *)&amp;l_LWIPMgr;  /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/

/* Common TCP functions */
$declare(AOs::LWIP_tcpAccept)
$declare(AOs::LWIP_tcpRecv)
$declare(AOs::LWIP_tcpSend)
$declare(AOs::LWIP_tcpSent)
$declare(AOs::LWIP_tcpPoll)
$declare(AOs::LWIP_tcpClose)
$declare(AOs::LWIP_tcpError)

/* UDP functions */
/**
  * @brief  This function is the UDP handler callback. It is automatically
  *             called by the LWIP stack when a new UDP message arrives.  It
  *             creates a new MsgEvt event (for CommStack) and publishes it to
  *             the shared CommStackMgr AO. IT SHOULD NOT BE CALLED DIRECTLY.
  *
  * @param  arg: a pointer to arg.  (Not currently used but in the original
  *             implementation of the callback.
  * @param  upcb: a pointer to the udb structure containing UDP connect data.
  * @param  p:  a pointer to the pbuf containing the received data.
  * @param  addr: a pointer to struct containing the IP data.
  * @param  part: a u16_t type containing the port number used to connect.
  * @retval None
  */
static void udp_rx_handler(void *arg, struct udp_pcb *upcb,
                           struct pbuf *p, struct ip_addr *addr, u16_t port);

/* Private functions ---------------------------------------------------------*/

$define(AOs::LWIPMgr_ctor)
$define(AOs::LWIPMgr)

/* Common TCP functions */
$define(AOs::LWIP_tcpAccept)
$define(AOs::LWIP_tcpRecv)
$define(AOs::LWIP_tcpSend)
$define(AOs::LWIP_tcpSent)
$define(AOs::LWIP_tcpPoll)
$define(AOs::LWIP_tcpClose)
$define(AOs::LWIP_tcpError)

/* Ethernet message sender ...................................................*/
void ETH_SendMsg_Handler(MsgEvt const *e) {

        /* 1. Construct a new msg event indicating that a msg has been received */
        EthEvt *ethEvt = Q_NEW(EthEvt, ETH_UDP_SEND_SIG);

        /* 2. Fill the msg payload with the message */
        MEMCPY(ethEvt-&gt;msg, e-&gt;msg, e-&gt;msg_len);
        ethEvt-&gt;msg_len = e-&gt;msg_len;

        /* 3. Publish the newly created EthEvt event to LWIPMgr AO */
        QF_PUBLISH((QEvent *)ethEvt, AO_LWIPMgr);
}

/* UDP handler ...............................................................*/
static void udp_rx_handler(void *arg, struct udp_pcb *upcb,
                           struct pbuf *p, struct ip_addr *addr, u16_t port) {

    /* 1. Construct a new msg event indicating that a msg has been received */
    MsgEvt *msgEvt = Q_NEW(MsgEvt, MSG_RECEIVED_SIG);

    /* 2. Fill the msg payload and get the msg source and length */
    MEMCPY(msgEvt-&gt;msg, p-&gt;payload, p-&gt;len);
    msgEvt-&gt;msg_len = p-&gt;len;

    /* 3. Don't bother publishing locally.  Instead, publish the newly created
     * MsgEvt event to CommStackMgr AO */
    QF_PUBLISH((QEvent *)msgEvt, AO_LWIPMgr);

    /* 4. connect to the remote host */
    udp_connect(upcb, addr, port);

    /* 5. Free up the pbuf */
    pbuf_free(p);
}

/**
 * @}
 * end addtogroup groupLWIP_QPC_Eth
 */

/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="LWIPMgr_gen.h">
   <text>/**
 * @file  LWIPMgr.h
 * @brief This file contains the declarations of the LWIPMgr Active Object and
 * its state machines.
 *
 * LWIPMgr is responsible for handling all communications with the ethernet
 * driver.  It is the only state machine that has exclusive access to the
 * ethernet hardware and facilitates sharing by allowing other state machines
 * to publish events to the QPC RTOS.  QPC queues the events to be handled by
 * the LWIPMgr state machine in the FIFO order.
 *
 * Note: If editing this file, please make sure to update the LWIPMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date       06/09/2014
 * @author     Harry Rostovtsev
 * @email      harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupLWIP_QPC_Eth
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef LWIPMGR_H_
#define LWIPMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;Shared.h&quot;

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
/*! \enum LWIPMgr Signals
 * Signals used by LWIPMgr.  These should start from MAX_SHARED_SIG
 */
enum LWIPMgrSignals {
    ETH_UDP_SEND_SIG = MAX_SHARED_SIG,
    ETH_DBG_TOGGLE_SIG,
    ETH_LOG_TCP_SEND_SIG,
    ETH_SYS_TCP_SEND_SIG,
    ETH_TCP_DATA_RECV_SIG,
    TCP_DONE_SIG,
    TCP_TIMEOUT_SIG,
    MAX_PUB_SIG,                                  /* the last published signal */
};

$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::LWIPMgr_ctor)
$declare(AOs::AO_LWIPMgr)

/**
 * @brief    Send UDP msg over ethernet.
 * This function is the implementation of a stub function in CommStackMgr.  It
 * is used to do the actual sending of data over ethernet on the embedded side.
 * The simulator will have its own implementation of this function due to the
 * use of totally different ip stacks and threading paradigms.
 *
 * @param [in,out] e: a MsgEvt const event pointer to the MsgEvt that contains the
 * length and message to be sent.
 *
 * @return None
 */
void ETH_SendMsg_Handler(MsgEvt const *e);

/**
 * @}
 * end addtogroup groupLWIP_QPC_Eth
 */
#endif                                                          /* LWIPMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
