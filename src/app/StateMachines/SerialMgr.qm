<?xml version="1.0" encoding="UTF-8"?>
<model version="2.2.03">
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="SerialDataEvt" superclass="qpc::QEvt">
   <documentation>This event type should be used to transport serial data.  It contains a large 
buffer </documentation>
   <attribute name="buffer[MAX_MSG_LEN]" type="char" visibility="0x01" properties="0x00">
    <documentation>Buffer to store the data</documentation>
   </attribute>
   <attribute name="wBufferLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>Amount of data in the buffer.</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="SerialMgr" superclass="qpc::QActive">
   <documentation>Active Object that manages output to debug serial port.  Upon receiving an event
it copies the data to the UART DMA buffer and activates DMA to do the actual 
outputting to serial, freeing up the system to continue to do real work. The
interrupt at the end of the DMA process disables the DMA and lets the AO know
that the transfer has completed.</documentation>
   <attribute name="serialTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>Used to timeout serial transfers if errors occur.</documentation>
   </attribute>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>native QF queue for deferred request events</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[100]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>storage for deferred event queue buffer</documentation>
   </attribute>
   <statechart>
    <initial target="../1/0">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_SerialMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;SerialMgr_initial);
QS_FUN_DICTIONARY(&amp;SerialMgr_Active);
QS_FUN_DICTIONARY(&amp;SerialMgr_Idle);
QS_FUN_DICTIONARY(&amp;SerialMgr_Busy);

QActive_subscribe((QActive *)me, UART_DMA_START_SIG);
QActive_subscribe((QActive *)me, UART_DMA_DONE_SIG);
QActive_subscribe((QActive *)me, UART_DMA_TIMEOUT_SIG);</action>
     <initial_glyph conn="1,2,4,3,11,5">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>This state is a catch-all Active state.  If any signals need
to be handled that do not cause state transitions and are 
common to the entire AO, they should be handled here.
 
@param  me: Pointer to the state machine
@param  e:  Pointer to the event being processed.
@retval status: QState type that specifies where the state
machine is going next.
</documentation>
     <entry>/* Post a timer and disarm it right away so it can be
 * rearmed at any point */
QTimeEvt_postIn(
    &amp;me-&gt;serialTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
);
QTimeEvt_disarm(&amp;me-&gt;serialTimerEvt);</entry>
     <state name="Idle">
      <documentation>This state indicates that the DMA is currently idle and the incoming msg can
be sent out to the DMA buffer to be printed out to the serial port.
 
@param  me: Pointer to the state machine
@param  e:  Pointer to the event being processed.
@retval status: QState type that specifies where the state
machine is going next.
</documentation>
      <entry>/* recall the request from the private requestQueue */
SerialDataEvt const *rq = (SerialDataEvt const *) (uint32_t) QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);

/* This IF/ELSE is for debug printing only.  You can remove this */
if (rq != (SerialDataEvt *)0) {
    /* recall posted an event? */
    debug_printf(&quot;Request recalled\n&quot;);
} else {
    debug_printf(&quot;No deferred requests\n&quot;);
}</entry>
      <tran trig="UART_DMA_START" target="../../1">
       <action>debug_printf(&quot;Got UART_DMA_START\n&quot;);
/* Set up the DMA buffer here */
Serial_DMAConfig(
    SYSTEM_SERIAL,
    (char *)((SerialDataEvt const *) e)-&gt;buffer,
    ((SerialDataEvt const *) e)-&gt;wBufferLen
);</action>
       <tran_glyph conn="25,14,1,3,17">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="6,8,19,39">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state name="Busy">
      <documentation>This state indicates that the DMA is currently busy outputting to the serial 
port and cannot process incoming data.  Instead, incoming events will be 
deferred in this state and handled once the AO goes back to Idle state.
 
@param  me: Pointer to the state machine
@param  e:  Pointer to the event being processed.
@retval status: QState type that specifies where the state
machine is going next.
</documentation>
      <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;serialTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
);

/* Start the DMA transfer over serial */
Serial_DMAStartXfer( SYSTEM_SERIAL );</entry>
      <exit>QTimeEvt_disarm( &amp;me-&gt;serialTimerEvt ); /* Disarm timer on exit */</exit>
      <tran trig="UART_DMA_DONE" target="../../0">
       <action>debug_printf(&quot;Got UART_DMA_DONE&quot;);</action>
       <tran_glyph conn="42,18,3,1,-17">
        <action box="-14,-2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="UART_DMA_TIMEOUT" target="../../0">
       <action>err_printf(&quot;UART DMA timeout occurred\n&quot;);</action>
       <tran_glyph conn="42,21,3,1,-17">
        <action box="-16,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="UART_DMA_START">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
} else {
   /* notify the request sender that the request was ignored.. */
   log_printf(&quot;Unable to defer UART_DMA_START request\n&quot;);
}</action>
       <tran_glyph conn="42,44,3,-1,17">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="42,8,20,39">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,3,63,47">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="73,58"/>
   </statechart>
  </class>
  <attribute name="AO_SerialMgr" type="QActive * const" visibility="0x00" properties="0x00"/>
  <operation name="SerialMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>This function is a C &quot;constructor&quot; for this AO.</documentation>
   <code>SerialMgr *me = &amp;l_SerialMgr;
QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;SerialMgr_initial);
QTimeEvt_ctor(&amp;me-&gt;serialTimerEvt, UART_DMA_TIMEOUT_SIG);

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="SerialMgr_gen.c">
   <text>/**
 * @file    SerialMgr.c
 * Declarations for functions for the SerialMgr AO.  This state
 * machine handles all output to the serial port
 *
 * Note: If editing this file, please make sure to update the SerialMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    06/02/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 */
#include &quot;SerialMgr.h&quot;
#include &quot;CBSignals.h&quot;                              /* Signal declarations. */
#include &quot;CBTimeouts.h&quot;                            /* Timeout declarations. */
#include &quot;bsp.h&quot;        /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include &quot;serial.h&quot;                             /* For serial functionality */
#include &lt;stdio.h&gt;

Q_DEFINE_THIS_FILE;

/* application signals cannot overlap the device-driver signals */
Q_ASSERT_COMPILE(MAX_SHARED_SIG &lt; DEV_DRIVER_SIG);

/* Active object class -----------------------------------------------------*/
$declare(AOs::SerialMgr)

/* Local objects -----------------------------------------------------------*/
static SerialMgr l_SerialMgr; /* the single instance of the active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_SerialMgr = (QActive *)&amp;l_SerialMgr;  /* &quot;opaque&quot; AO pointer */

$define(AOs::SerialMgr_ctor)
$define(AOs::SerialMgr)

/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="SerialMgr_gen.h">
   <text>/**
 * @file    SerialMgr.h
 * Declarations for functions for the SerialMgr AO.  This state
 * machine handles all output to the serial port
 *
 * Note: If editing this file, please make sure to update the CommStackMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    06/02/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 */
#ifndef SERIALMGR_H_
#define SERIALMGR_H_

#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;                                   /*  Common Declarations */

$declare(AOs::SerialMgr_ctor)
$declare(AOs::AO_SerialMgr)
$declare(Events)

#endif                                                        /* SERIALMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
