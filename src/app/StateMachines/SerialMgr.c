/*****************************************************************************
* Model: SerialMgr.qm
* File:  ./SerialMgr_gen.c
*
* This file has been generated automatically by QP Modeler (QM).
* DO NOT EDIT THIS FILE MANUALLY.
*
* Please visit www.state-machine.com/qm for more information.
*****************************************************************************/
/**
 * @file    SerialMgr.c
 * Declarations for functions for the SerialMgr AO.  This state
 * machine handles all output to the serial port
 *
 * Note: If editing this file, please make sure to update the SerialMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    06/02/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 */
#include "SerialMgr.h"
#include "project_includes.h"         /* Includes common to entire project. */
#include "bsp.h"        /* For seconds to bsp tick conversion (SEC_TO_TICK) */

Q_DEFINE_THIS_FILE;

/* application signals cannot overlap the device-driver signals */
Q_ASSERT_COMPILE(MAX_SHARED_SIG < DEV_DRIVER_SIG);

/* Active object class -----------------------------------------------------*/
/* @(/2/0) .................................................................*/
/** 
* Active Object that manages output to debug serial port.  Upon receiving an event
* it copies the data to the UART DMA buffer and activates DMA to do the actual 
* outputting to serial, freeing up the system to continue to do real work. The
* interrupt at the end of the DMA process disables the DMA and lets the AO know
* that the transfer has completed.
*/
typedef struct SerialMgrTag {
/* protected: */
    QActive super;
    /** 
    * Used to timeout serial transfers if errors occur.
    */
    QTimeEvt serialTimerEvt;
    /** 
    * native QF queue for deferred request events
    */
    QEQueue deferredEvtQueue;
    /** 
    * storage for deferred event queue buffer
    */
    QTimeEvt const * deferredEvtQSto[100];
} SerialMgr;

/* protected: */
static QState SerialMgr_initial(SerialMgr * const me, QEvt const * const e);

/** 
* This state is a catch-all Active state.  If any signals need
* to be handled that do not cause state transitions and are 
* common to the entire AO, they should be handled here.
*  
* @param  me: Pointer to the state machine
* @param  e:  Pointer to the event being processed.
* @retval status: QState type that specifies where the state
* machine is going next.
* 
*/
static QState SerialMgr_Active(SerialMgr * const me, QEvt const * const e);

/** 
* This state indicates that the DMA is currently idle and the incoming msg can
* be sent out to the DMA buffer to be printed out to the serial port.
*  
* @param  me: Pointer to the state machine
* @param  e:  Pointer to the event being processed.
* @retval status: QState type that specifies where the state
* machine is going next.
* 
*/
static QState SerialMgr_Idle(SerialMgr * const me, QEvt const * const e);

/** 
* This state indicates that the DMA is currently busy outputting to the serial 
* port and cannot process incoming data.  Instead, incoming events will be 
* deferred in this state and handled once the AO goes back to Idle state.
*  
* @param  me: Pointer to the state machine
* @param  e:  Pointer to the event being processed.
* @retval status: QState type that specifies where the state
* machine is going next.
* 
*/
static QState SerialMgr_Busy(SerialMgr * const me, QEvt const * const e);


/* Local objects -----------------------------------------------------------*/
static SerialMgr l_SerialMgr; /* the single instance of the active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_SerialMgr = (QActive *)&l_SerialMgr;  /* "opaque" AO pointer */

/* @(/2/2) .................................................................*/
void SerialMgr_ctor(void) {
    SerialMgr *me = &l_SerialMgr;
    QActive_ctor(&me->super, (QStateHandler)&SerialMgr_initial);
    QTimeEvt_ctor(&me->serialTimerEvt, UART_DMA_TIMEOUT_SIG);

    /* Initialize the deferred event queue and storage for it */
    QEQueue_init(
        &me->deferredEvtQueue,
        (QEvt const **)( me->deferredEvtQSto ),
        Q_DIM(me->deferredEvtQSto)
    );
}
/* @(/2/0) .................................................................*/
/* @(/2/0/3) ...............................................................*/
/* @(/2/0/3/0) */
static QState SerialMgr_initial(SerialMgr * const me, QEvt const * const e) {
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_SerialMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&SerialMgr_initial);
    QS_FUN_DICTIONARY(&SerialMgr_Active);
    QS_FUN_DICTIONARY(&SerialMgr_Idle);
    QS_FUN_DICTIONARY(&SerialMgr_Busy);

    QActive_subscribe((QActive *)me, UART_DMA_START_SIG);
    QActive_subscribe((QActive *)me, UART_DMA_DONE_SIG);
    QActive_subscribe((QActive *)me, UART_DMA_TIMEOUT_SIG);
    return Q_TRAN(&SerialMgr_Idle);
}
/* @(/2/0/3/1) .............................................................*/
static QState SerialMgr_Active(SerialMgr * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/2/0/3/1) */
        case Q_ENTRY_SIG: {
            /* Post a timer and disarm it right away so it can be
             * rearmed at any point */
            QTimeEvt_postIn(
                &me->serialTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
            );
            QTimeEvt_disarm(&me->serialTimerEvt);
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status;
}
/* @(/2/0/3/1/0) ...........................................................*/
static QState SerialMgr_Idle(SerialMgr * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/2/0/3/1/0) */
        case Q_ENTRY_SIG: {
            /* recall the request from the private requestQueue */
            SerialDataEvt const *rq = (SerialDataEvt const *) (uint32_t) QActive_recall(
                (QActive *)me,
                &me->deferredEvtQueue
            );
            status = Q_HANDLED();
            break;
        }
        /* @(/2/0/3/1/0/0) */
        case UART_DMA_START_SIG: {
            /* Set up the DMA buffer here.  This copies the data from the event to the UART's
             * private buffer as well to avoid someone overwriting it */
            Serial_DMAConfig(
                SYSTEM_SERIAL,
                (char *)((SerialDataEvt const *) e)->buffer,
                ((SerialDataEvt const *) e)->wBufferLen
            );
            status = Q_TRAN(&SerialMgr_Busy);
            break;
        }
        default: {
            status = Q_SUPER(&SerialMgr_Active);
            break;
        }
    }
    return status;
}
/* @(/2/0/3/1/1) ...........................................................*/
static QState SerialMgr_Busy(SerialMgr * const me, QEvt const * const e) {
    QState status;
    switch (e->sig) {
        /* @(/2/0/3/1/1) */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->serialTimerEvt,
                SEC_TO_TICKS( LL_MAX_TIMEOUT_SERIAL_DMA_BUSY_SEC )
            );

            /* Start the DMA transfer over serial */
            Serial_DMAStartXfer( SYSTEM_SERIAL );
            status = Q_HANDLED();
            break;
        }
        /* @(/2/0/3/1/1) */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm( &me->serialTimerEvt ); /* Disarm timer on exit */
            status = Q_HANDLED();
            break;
        }
        /* @(/2/0/3/1/1/0) */
        case UART_DMA_DONE_SIG: {
            status = Q_TRAN(&SerialMgr_Idle);
            break;
        }
        /* @(/2/0/3/1/1/1) */
        case UART_DMA_TIMEOUT_SIG: {
            err_printf("UART DMA timeout occurred\n");
            status = Q_TRAN(&SerialMgr_Idle);
            break;
        }
        /* @(/2/0/3/1/1/2) */
        case UART_DMA_START_SIG: {
            if (QEQueue_getNFree(&me->deferredEvtQueue) > 0) {
               /* defer the request - this event will be handled
                * when the state machine goes back to Idle state */
               QActive_defer((QActive *)me, &me->deferredEvtQueue, e);
            } else {
               /* notify the request sender that the request was ignored.. */
               log_printf("Unable to defer UART_DMA_START request\n");
            }
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&SerialMgr_Active);
            break;
        }
    }
    return status;
}


/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/
