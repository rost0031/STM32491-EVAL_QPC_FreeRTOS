<?xml version="1.0" encoding="UTF-8"?>
<model version="3.1.3">
 <documentation>/**
 * GuiMgr Active Object which.  This AO handles all LCD/TSC/GUI work.
 */</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01"/>
 <package name="AOs" stereotype="0x02">
  <class name="GuiMgr" superclass="qpc::QActive">
   <documentation>/**
 * \brief MenuMgr &quot;class&quot;
 */</documentation>
   <attribute name="lcdTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer to periodically ask for position updates from the touch screen.
 * This timer is started upon receiving the GUI_TSC_INTERRUPT_SIG, only after
 * checking if the touch screen is still being touched. Once the position data
 * indicates that the touchscreen is no longer being touched, the timer is
 * disarmed until the next time an interrupt occurs. */</documentation>
   </attribute>
   <attribute name="_x" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/* Holds the X position last read from the touch screen. */</documentation>
   </attribute>
   <attribute name="_y" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/* Holds the Y position last read from the touch screen. */</documentation>
   </attribute>
   <attribute name="tsPressed" type="bool" visibility="0x01" properties="0x00">
    <documentation>/**&lt; This variable keeps track of whether the touchscreen is currently pressed or
 * not.  If pressed, this flag is used to keep setting the timer to request LCD
 * position data from the touch screen controller. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

/* Init some variables to a sane state. */
me-&gt;tsPressed = false;
me-&gt;_x = 0;
me-&gt;_y = 0;

/* Activate the use of memory device feature */
WM_SetCreateFlags(WM_CF_MEMDEV);

/* Init the STemWin GUI Library */
GUI_Init();

/* Display a test message to verify LCD is working */
//GUI_DispStringAt(&quot;Hello World!&quot;, 0, 0);

QS_OBJ_DICTIONARY(&amp;l_GuiMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;GuiMgr_initial);
QS_FUN_DICTIONARY(&amp;GuiMgr_Active);</action>
     <initial_glyph conn="1,2,4,3,7,2">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>DBG_printf(&quot;GuiMgr successfully started\n&quot;);

/* Post all the timers and disarm them right away so it can be
 * rearmed at any point without worrying asserts. */
QTimeEvt_postIn(
    &amp;me-&gt;lcdTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( LL_MAX_TIME_SEC_LCD_UPDATE )
);
QTimeEvt_disarm(&amp;me-&gt;lcdTimerEvt);

l_cb_WM_HBKWIN = WM_SetCallback(WM_HBKWIN, &amp;onMainWndGUI);

             /* create the diaglog box and return right away... */
l_hDlg = GUI_CreateDialogBox(
    l_dialog, // Pointer to widget
    GUI_COUNTOF(l_dialog), // Number of widgets
    &amp;onDialogGUI, //Callback to call on completion
    0,    // Parent
    0,    // X0 position
    0     // Y0 position
);

WM_Exec();                 /* update the screen and invoke WM callbacks */</entry>
     <tran trig="GUI_TSC_INTERRUPT">
      <action>DBG_printf(&quot;Got GUI_TSC_INTERRUPT\n&quot;);

/* This flag is watched by the GUI_LCD_POS_DATA to see if we need to continue to
 * request TSC position data.  This interrupt signal kicks the process off.*/
me-&gt;tsPressed = true;

/* Direct post an event to ourself to request LCD position update data 
 * from I2C1DevMgr AO. The reason for posting this event to this AO instead
 * of posting directly to the I2C1Dev AO is so all the timer logic can be
 * handled in the GUI_LCD_POS_DATA_SIG handler. */
static QEvt const qEvt = { GUI_LCD_POS_UPDATE_TIMER_SIG, 0U, 0U };
QACTIVE_POST(AO_GuiMgr, &amp;qEvt, me);</action>
      <tran_glyph conn="3,84,3,-1,20">
       <action box="0,-2,17,2"/>
      </tran_glyph>
     </tran>
     <tran trig="GUI_LCD_POS_UPDATE_TIMER">
      <action>/* Direct post an event to request LCD position update data from I2C1DevMgr AO. */
static QEvt const qEvt = { TSC_POS_READ_SIG, 0U, 0U };
QACTIVE_POST(AO_I2C1DevMgr, &amp;qEvt, me);</action>
      <tran_glyph conn="3,80,3,-1,20">
       <action box="0,-2,24,2"/>
      </tran_glyph>
     </tran>
     <tran trig="GUI_LCD_POS_DATA">
      <action>/*
char tmp[120];
memset(tmp, 0, sizeof(tmp));
uint16_t tmpLen = 0;
CBErrorCode err = CON_hexToStr(
    (const uint8_t *)((I2CBusDataEvt const *)e)-&gt;dataBuf, // data to convert
    ((I2CBusDataEvt const *)e)-&gt;dataLen, // length of data to convert
    tmp,                                 // where to write output
    sizeof(tmp),                         // max size of output buffer
    &amp;tmpLen,                             // size of the resulting output
    0,                                   // no columns
    ' '                                  // separator
);
if ( ERR_NONE != err ) {
    WRN_printf(&quot;Got an error converting hex array to string.  Error: 0x%08x\n&quot;, err);
}
DBG_printf(&quot;Read LCD POS array: %s\n&quot;, tmp);
*/

/* Update the TSC position and notify the GUI/LCD system. */
GUI_PID_STATE TS_State;
uint32_t xDiff, yDiff , x , y;
x = ((I2CBusDataEvt const *)e)-&gt;dataBuf[2] | ((I2CBusDataEvt const *)e)-&gt;dataBuf[1] &lt;&lt; 8;
y = ((I2CBusDataEvt const *)e)-&gt;dataBuf[4] | ((I2CBusDataEvt const *)e)-&gt;dataBuf[3] &lt;&lt; 8;

DBG_printf(&quot;X=%0x, Y=%0x\n&quot;, x, y);
if(((x == 0xFFFF ) &amp;&amp; (y == 0xFFFF ))|| ((x == 0 ) &amp;&amp; (y == 0 ))) {
    me-&gt;tsPressed = false;
}

if ( me-&gt;tsPressed == true ) {
    x = ((I2CBusDataEvt const *)e)-&gt;dataBuf[2] | ((I2CBusDataEvt const *)e)-&gt;dataBuf[1] &lt;&lt; 8;
    y = ((I2CBusDataEvt const *)e)-&gt;dataBuf[4] | ((I2CBusDataEvt const *)e)-&gt;dataBuf[3] &lt;&lt; 8;
    xDiff = x &gt; me-&gt;_x ? (x - me-&gt;_x) : (me-&gt;_x - x);
    yDiff = y &gt; me-&gt;_y ? (y - me-&gt;_y) : (me-&gt;_y - y);
    if ((xDiff + yDiff &gt; 2)) {
        me-&gt;_x = x;
        me-&gt;_y = y;
    }
    /* TSC is still being touched, rearm the timer to keep updating TSC
     * position. */
    QTimeEvt_rearm(
        &amp;me-&gt;lcdTimerEvt,
        SEC_TO_TICKS( LL_MAX_TIME_SEC_LCD_UPDATE )
    );
} else {
    /* TSC not being touched.  Turn off the timer that triggers
     * GUI_LCD_POS_UPDATE_TIMER signals which request TSC position data.*/
    QTimeEvt_disarm(&amp;me-&gt;lcdTimerEvt);
}

TS_State.x = me-&gt;_x;
TS_State.y = me-&gt;_y;
TS_State.Pressed = me-&gt;tsPressed;
TS_State.Layer = 0;

if(
    (TS_State.x &gt;= 0 ) &amp;&amp;
    (TS_State.x &lt; LCD_GetXSize()) &amp;&amp;
    (TS_State.y &gt;= 0 ) &amp;&amp;
    (TS_State.y &lt; LCD_GetYSize())
) {
    GUI_TOUCH_StoreStateEx(&amp;TS_State);
}
</action>
      <tran_glyph conn="3,76,3,-1,20">
       <action box="0,-2,18,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="3,3,101,85">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="108,90"/>
   </statechart>
  </class>
  <attribute name="AO_GuiMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="GuiMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for GuiMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */</documentation>
   <code>GuiMgr *me = &amp;l_GuiMgr;
QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;GuiMgr_initial);
QTimeEvt_ctor( &amp;me-&gt;lcdTimerEvt, GUI_LCD_POS_UPDATE_TIMER_SIG );</code>
  </operation>
 </package>
 <directory name=".">
  <file name="GuiMgr_gen.c">
   <text>/**
 * @file    GuiMgr.c
 * Definitions for functions for the GuiMgr AO.  This state machine handles
 * all touchscreen, LCD, and GUI events and actions.
 *
 * Note: If editing this file, please make sure to update the GuiMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    11/06/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupGui
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;GuiMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;GUI.h&quot;
#include &quot;WM.h&quot;                                      /* emWin Windows Manager */
#include &quot;DIALOG.h&quot;
#include &quot;I2CBusMgr.h&quot;
#include &quot;I2C1DevMgr.h&quot;

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_GUI ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::GuiMgr)

/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/

static GuiMgr l_GuiMgr;           /* the single instance of the active object */

/* GUI handles */
static WM_HWIN      l_hDlg;
static WM_CALLBACK *l_cb_WM_HBKWIN;
static const GUI_WIDGET_CREATE_INFO l_dialog[] = {
    { &amp;FRAMEWIN_CreateIndirect, &quot;Main Window&quot;,
        0,  30,  30, 260, 180, FRAMEWIN_CF_MOVEABLE },
    { &amp;TEXT_CreateIndirect, &quot;Thing 1&quot;,
        GUI_ID_TEXT9,  50,  10, 0, 0, TEXT_CF_LEFT },
    { &amp;TEXT_CreateIndirect, &quot;Thing 2&quot;,
        GUI_ID_TEXT9,  50,  30, 0, 0, TEXT_CF_LEFT },

    { &amp;TEXT_CreateIndirect, &quot;status 1&quot;,
        GUI_ID_TEXT0, 130,  10, 0, 0, TEXT_CF_LEFT },
    { &amp;TEXT_CreateIndirect, &quot;status 2&quot;,
        GUI_ID_TEXT1, 130,  30, 0, 0, TEXT_CF_LEFT },

    { &amp;BUTTON_CreateIndirect,&quot;Button&quot;,
        GUI_ID_BUTTON0,    160, 130, 80, 30 }
};
/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_GuiMgr = (QActive *)&amp;l_GuiMgr;      /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
/*..........................................................................*/
static void onMainWndGUI(WM_MESSAGE* pMsg) {
    switch (pMsg-&gt;MsgId) {
        case WM_PAINT: {
            GUI_SetBkColor(GUI_GRAY);
            GUI_Clear();
            GUI_SetColor(GUI_BLACK);
            GUI_SetFont(&amp;GUI_Font24_ASCII);
            GUI_DispStringHCenterAt(&quot;Window Manager Test&quot;, 160, 5);
            break;
        }
        default: {
            WM_DefaultProc(pMsg);
            break;
        }
    }
}

/*..........................................................................*/
static void onDialogGUI(WM_MESSAGE * pMsg) {
    switch (pMsg-&gt;MsgId) {
        case WM_INIT_DIALOG: {
            break;
        }
        case WM_NOTIFY_PARENT: {
            switch (pMsg-&gt;Data.v) {
                case WM_NOTIFICATION_RELEASED: {  /* react only if released */
                    switch (WM_GetId(pMsg-&gt;hWinSrc)) {
                        case GUI_ID_BUTTON0: {
                                     /* static PAUSE event for the Table AO */
                            static QEvent const pauseEvt = { GUI_TEST_SIG, 0 };
                            QACTIVE_POST(AO_GuiMgr, &amp;pauseEvt, &amp;l_onDialogGUI);
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }
        default: {
            WM_DefaultProc(pMsg);
            break;
        }
    }
}

$define(AOs::GuiMgr_ctor)
$define(AOs::GuiMgr)


/**
 * @} end addtogroup groupGui
 */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="GuiMgr_gen.h">
   <text>/**
 * @file    GuiMgr.h
 * Declarations for functions for the GuiMgr AO.  This state machine handles
 * all touchscreen, LCD, and GUI events and actions.
 *
 * Note: If editing this file, please make sure to update the GuiMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    11/06/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupGui
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef GUIMGR_H_
#define GUIMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;Shared.h&quot;

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::GuiMgr_ctor)
$declare(AOs::AO_GuiMgr)

/**
 * @} end addtogroup groupGui
 */
#endif                                                           /* GUIMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
